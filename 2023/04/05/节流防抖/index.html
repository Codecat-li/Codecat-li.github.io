<!DOCTYPE html><html lang="zh-cmn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1,user-scalable=no"><meta name="renderer" content="webkit"><meta name="color-scheme" content="dark light"><meta name="author" content="李宝霖"><meta name="description" content=""><meta name="keywords" content=""><title>子安的前端世界</title><link rel="icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="//at.alicdn.com/t/font_3242539_utq6ykfq7z.css"><link rel="stylesheet" light-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/default.min.css" dark-src="https://cdn.staticfile.org/highlight.js/11.5.0/styles/tokyo-night-dark.min.css"><link rel="stylesheet" href="https://fonts.font.im/css?family=Noto+Serif" as="font"><link href="/style/index.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="子安的前端世界" type="application/atom+xml">
</head><body><header class="page-header"><nav><ul class="router-list"><li class="nav-item"> <a href="/">主页</a></li><li class="nav-item"> <a href="/archives/">归档</a></li><li class="nav-item"> <a href="/atom.xml">RSS</a></li></ul><div class="mode-switch"><span class="iconfont icon-DarkTheme"></span></div></nav></header><main><section class="main-content"><section class="post-page"><div class="title-bar"><h1></h1><div class="post-info"><span>2023-04-05 09:29:18</span><span class="tags"></span></div></div><article> <div class="content"><h1 id="JavaScript-进阶-第4天"><a href="#JavaScript-进阶-第4天" class="headerlink" title="JavaScript 进阶 - 第4天"></a>JavaScript 进阶 - 第4天</h1><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>首先浅拷贝和深拷贝只针对引用类型</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝：拷贝的是地址</p>
<p>常见方法：</p>
<ol>
<li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li>
<li>拷贝数组：Array.prototype.concat() 或者 […arr]</li>
</ol>
<blockquote>
<p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 。</p>
</blockquote>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝：拷贝的是对象，不是地址</p>
<p>常见方法：</p>
<ol>
<li>通过递归实现深拷贝</li>
<li>lodash&#x2F;cloneDeep</li>
<li>通过JSON.stringify()实现</li>
</ol>
<h4 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h4><p>函数递归：由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;
  <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,
  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],
  <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;
<span class="hljs-keyword">const</span> o = &#123;&#125;
<span class="hljs-comment">// 拷贝函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">newObj, oldObj</span>) &#123;
  <span class="hljs-keyword">debugger</span><span class="hljs-comment">//相当于断点调试</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldObj) &#123;
    <span class="hljs-comment">// 处理数组的问题  一定先写数组 在写 对象 不能颠倒</span>
    <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;
      newObj[k] = []
      <span class="hljs-comment">//  newObj[k] 接收 []  hobby</span>
      <span class="hljs-comment">//  oldObj[k]   [&#x27;乒乓球&#x27;, &#x27;足球&#x27;]</span>
      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;
      newObj[k] = &#123;&#125;
      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])&#125;
    <span class="hljs-keyword">else</span> &#123;
      <span class="hljs-comment">//  k  属性名 uname age    oldObj[k]  属性值  18</span>
      <span class="hljs-comment">// newObj[k]  === o.uname  给新对象添加属性</span>
      newObj[k] = oldObj[k]&#125;&#125;&#125;
<span class="hljs-title function_">deepCopy</span>(o, obj) <span class="hljs-comment">// 函数调用  两个参数 o 新对象  obj 旧对象</span>
o.<span class="hljs-property">hobby</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;篮球&#x27;</span>
o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">23</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</code></pre>

<h4 id="js库lodash里面cloneDeep内部实现了深拷贝"><a href="#js库lodash里面cloneDeep内部实现了深拷贝" class="headerlink" title="js库lodash里面cloneDeep内部实现了深拷贝"></a>js库lodash里面cloneDeep内部实现了深拷贝</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span>
<span class="language-javascript">   <span class="hljs-keyword">const</span> obj = &#123;</span>
<span class="language-javascript">     <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,</span>
<span class="language-javascript">     <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],</span>
<span class="language-javascript">     <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;</span>
<span class="language-javascript">   <span class="hljs-keyword">const</span> o = _.<span class="hljs-title function_">cloneDeep</span>(obj)</span>
<span class="language-javascript">   o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span></span>
<span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>

<h4 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 把对象转换为 JSON 字符串</span>
<span class="hljs-keyword">const</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))</code></pre>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;
   <span class="hljs-keyword">if</span>(!x || !y) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数不能为空!&#x27;</span>)&#125;<span class="hljs-comment">// throw &#x27;参数不能为空!&#x27;;</span>
   <span class="hljs-keyword">return</span> x + y&#125;
 <span class="hljs-title function_">counter</span>()</code></pre>

<p>总结：</p>
<ol>
<li><code>throw</code> 抛出异常信息，程序也会终止执行</li>
<li><code>throw</code> 后面跟的是错误提示信息</li>
<li><code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息</li>
</ol>
<h3 id="try-…-catch"><a href="#try-…-catch" class="headerlink" title="try … catch"></a>try … catch</h3><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;
   <span class="hljs-keyword">try</span> &#123;
     <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.p&#x27;</span>)
     p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>&#125; 
    <span class="hljs-keyword">catch</span> (error) &#123;
     <span class="hljs-comment">// try 代码段中执行有错误时，会执行 catch 代码段</span>
     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)
     <span class="hljs-comment">// 终止代码继续执行</span>
     <span class="hljs-keyword">return</span>&#125;
   <span class="hljs-keyword">finally</span> &#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;执行&#x27;</span>)&#125; 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;如果出现错误，我的语句不会执行&#x27;</span>)&#125;
 <span class="hljs-title function_">foo</span>()</code></pre>

<p>总结：</p>
<ol>
<li><code>try...catch</code> 用于捕获错误信息</li>
<li>将预估可能发生错误的代码写在 <code>try</code> 代码段中</li>
<li>如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li>
</ol>
<h2 id="处理this"><a href="#处理this" class="headerlink" title="处理this"></a>处理this</h2><p><code>this</code> 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 <code>this</code> 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 <code>this</code> 默认的取值】情况进行归纳和总结。</p>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p><strong>普通函数</strong>的调用方式决定了 <code>this</code> 的值，即【谁调用 <code>this</code> 的值指向谁】，如下代码所示：</p>
<pre><code class="hljs javascript">  <span class="hljs-comment">// 普通函数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;
  <span class="hljs-comment">// 函数表达式</span>
  <span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;
  <span class="hljs-comment">// 函数的调用方式决定了 this 的值</span>
  <span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// window</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayHi</span>()
<span class="hljs-comment">// 普通对象</span>
  <span class="hljs-keyword">const</span> user = &#123;
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,
    <span class="hljs-attr">walk</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;&#125;
  <span class="hljs-comment">// 动态为 user 添加方法</span>
  user.<span class="hljs-property">sayHi</span> = sayHi
  uesr.<span class="hljs-property">sayHello</span> = sayHello
  <span class="hljs-comment">// 函数调用方式，决定了 this 的值</span>
  user.<span class="hljs-title function_">sayHi</span>()
  user.<span class="hljs-title function_">sayHello</span>()</code></pre>

<p>注： 普通函数没有明确调用者时 <code>this</code> 值为 <code>window</code>，严格模式下没有调用者时 <code>this</code> 的值为 <code>undefined</code>。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数</strong>中的 <code>this</code> 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 <code>this</code> ！箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p>
<pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 此处为 window</span>
<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">const</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this </span>
<span class="hljs-comment">// 普通对象</span>
<span class="hljs-keyword">const</span> user = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,
  <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this 一致</span>
  <span class="hljs-attr">walk</span>: <span class="hljs-function">() =&gt;</span> &#123;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;,
  <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 与 sleep 中的 this 一致</span>
    <span class="hljs-comment">// 调用箭头函数</span>
    <span class="hljs-title function_">fn</span>();&#125;&#125;
<span class="hljs-comment">// 动态添加方法</span>
user.<span class="hljs-property">sayHi</span> = sayHi
<span class="hljs-comment">// 函数调用</span>
user.<span class="hljs-title function_">sayHi</span>()</code></pre>

<p>在开发中【使用箭头函数前需要考虑函数中 <code>this</code> 的值】，<strong>事件回调函数</strong>使用箭头函数时，<code>this</code> 为全局的 <code>window</code>，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>)
<span class="hljs-comment">// 箭头函数 此时 this 指向了 window</span>
btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)
<span class="hljs-comment">// 普通函数 此时 this 指向了 DOM 对象</span>
btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)</code></pre>

<p>同样由于箭头函数 <code>this</code> 的原因，<strong>基于原型的面向对象也不推荐采用箭头函数</strong>，如下代码所示：</p>
<pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;
<span class="hljs-comment">// 原型对像上添加了箭头函数</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">walk</span> = <span class="hljs-function">() =&gt;</span> &#123;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125; <span class="hljs-comment">// window</span>
<span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()
p1.<span class="hljs-title function_">walk</span>()</code></pre>

<h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p>以上归纳了普通函数和箭头函数中关于 <code>this</code> 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 <code>this</code> 的指向，有 3 个方法可以动态指定普通函数中 <code>this</code> 的指向：</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125;
<span class="hljs-keyword">let</span> user = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;
<span class="hljs-keyword">let</span> student = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;
<span class="hljs-comment">// 调用函数并指定 this 的值</span>
sayHi.<span class="hljs-title function_">call</span>(user); <span class="hljs-comment">// this 值为 user</span>
sayHi.<span class="hljs-title function_">call</span>(student); <span class="hljs-comment">// this 值为 student</span>
<span class="hljs-comment">// 求和函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">return</span> x + y;&#125;
<span class="hljs-comment">// 调用 counter 函数，并传入参数</span>
<span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre>

<p>总结：</p>
<ol>
<li><code>call</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>
<li>使用 <code>call</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>
<li><code>call</code> 方法的其余参数会依次自动传入函数做为函数的参数</li>
</ol>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;
<span class="hljs-keyword">let</span> user = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;
<span class="hljs-keyword">let</span> student = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;
<span class="hljs-comment">// 调用函数并指定 this 的值</span>
sayHi.<span class="hljs-title function_">apply</span>(user) <span class="hljs-comment">// this 值为 user</span>
sayHi.<span class="hljs-title function_">apply</span>(student) <span class="hljs-comment">// this 值为 student</span>
<span class="hljs-comment">// 求和函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;
  <span class="hljs-keyword">return</span> x + y&#125;
<span class="hljs-comment">// 调用 counter 函数，并传入参数</span>
<span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>])</code></pre>

<p>总结：</p>
<ol>
<li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li>
<li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li>
<li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li>
</ol>
<h4 id="bind（重点）"><a href="#bind（重点）" class="headerlink" title="bind（重点）"></a>bind（重点）</h4><p><code>bind</code> 方法并<strong>不会调用函数</strong>，而是创建一个指定了 <code>this</code> 值的新函数，使用方法如下代码所示：</p>
<pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;
<span class="hljs-keyword">let</span> user = &#123;
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;
<span class="hljs-comment">// 调用 bind 指定 this 的值</span>
<span class="hljs-keyword">let</span> sayHello = sayHi.<span class="hljs-title function_">bind</span>(user);
<span class="hljs-comment">// 调用使用 bind 创建的新函数</span>
<span class="hljs-title function_">sayHello</span>()</code></pre>

<p>注：<code>bind</code> 方法创建新的函数，与原函数的唯一的变化是改变了 <code>this</code> 的值。</p>
<h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><ol>
<li>防抖（debounce）<br>  所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</li>
</ol>
<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)
    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>  
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125; <span class="hljs-comment">// 如果里面存在大量操作 dom 的情况，会卡顿</span>
    <span class="hljs-comment">// 防抖函数</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, t</span>) &#123;
      <span class="hljs-keyword">let</span> timeId
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
        <span class="hljs-comment">// 如果有定时器就清除</span>
        <span class="hljs-keyword">if</span> (timeId) <span class="hljs-built_in">clearTimeout</span>(timeId)
        <span class="hljs-comment">// 开启定时器 200</span>
        timeId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()&#125;, t)&#125;&#125;
    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">debounce</span>(mouseMove, <span class="hljs-number">200</span>))</code></pre>
<ol start="2">
<li>节流（throttle）<br>  所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)
   <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>
   <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125;
   <span class="hljs-comment">// 节流函数</span>
   <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, t</span>) &#123;
     <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;
       <span class="hljs-comment">//如果没有定时器就创建定时器</span>
       <span class="hljs-keyword">if</span> (!timer) &#123;
         timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()
           timer = <span class="hljs-literal">null</span> &#125;, t)&#125;&#125;&#125;
   box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">throttle</span>(mouseMove, <span class="hljs-number">2000</span>))</code></pre></li>
</ol>
</div></article><div class="copyright-wrapper"><p>原文作者:<a href="http://example.com">李宝霖</a></p><p>原文链接:<a href="http://example.com/2023/04/05/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"></a></p><p>发表日期: 2023-04-05 09:29:18</p><p>更新日期: 2023-04-05 09:48:28</p><p>版权声明: 本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p></div><div class="post-pager"><div class="prev"></div><div class="next"> <a href="/2023/04/05/this%E4%B8%8E%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/" title="">下一篇 </a></div></div><link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css"/><script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script><div id="gitalk-container"></div><script>new Gitalk({
  clientID: '',
  clientSecret: '',
  repo: '',
  owner: '李宝霖',
  admin: '李宝霖',
  id: location.pathname.substr(0, 48),
  distractionFreeMode: true,
  labels: ['Gitalk'],
  title: '',
}).render('gitalk-container');</script></section></section></main><footer class="footer-page"><div><span>Powered by</span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a><span>| Theme</span><a target="_blank" rel="noopener" href="https://github.com/techmovie/hexo-theme-instapaper">instapaper</a></div></footer><script src="/scripts/dark.js"></script><script src="/scripts/post.js"></script></body></html>