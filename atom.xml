<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子安的前端世界</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-18T09:07:32.086Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李宝霖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序API</title>
    <link href="http://example.com/2023/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/"/>
    <id>http://example.com/2023/05/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/</id>
    <published>2023-05-17T08:27:52.760Z</published>
    <updated>2023-05-18T09:07:32.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事件监听API"><a href="#事件监听API" class="headerlink" title="事件监听API"></a>事件监听API</h3><p>以on开头，用来监听某些事件的触发。</p><h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><p>以sync结尾，可以同步API的执行结果，通过函数返回值直接获取，如果执行出错会抛出异常</p><h3 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h3><p>类似$.ajax函数，需要通过success、fail、complete接收调用的结果。</p><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>类似于VUE的插值语法</p><pre><code class="hljs vue">&lt;!--动态绑定内容--&gt;&lt;view&gt;&#123;&#123;info&#125;&#125;&lt;/view&gt;&lt;image src=&quot;&#123;&#123;src&#125;&#125;&quot;&gt;&lt;/image&gt;&lt;view&gt;&#123;&#123;ew?true:false&#125;&#125;&lt;/view&gt;----data:&#123;info: &quot;qwe&quot;src:&quot;dfd/dfd/fdf&quot;&#125;</code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h4 id="target和currentTarget的区别"><a href="#target和currentTarget的区别" class="headerlink" title="target和currentTarget的区别"></a>target和currentTarget的区别</h4><p>target是触发该事件的源头组件，currentTarget是当前事件所绑定的组件。</p><h4 id="bindtap语法格式"><a href="#bindtap语法格式" class="headerlink" title="bindtap语法格式"></a>bindtap语法格式</h4><pre><code class="hljs vue">&lt;view&gt;    &lt;button bindtap=&quot;bindHandler&quot; data-info=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;input bindinput=&quot;inputHandler&quot;&gt;&lt;/view&gt;---------/**   * 为data里的数据赋值，在小程序里传参必须用data-info，这点和vue不同。   */bindHandler(e)&#123; console.log(e);    this.setData(&#123;      count: this.data.count +1    &#125;)  &#125;,inputHandler(e)&#123; console.log(e.detail.value);  &#125;,  /**   * 页面的初始数据   */  data: &#123;    count: 0  &#125;,-----------log打印&#123;target:  dataset:    info: 2&#125;</code></pre><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><pre><code class="hljs vue">&lt;!--我们可以用block来包裹要渲染的部分，从而避免渲染多余的节点--&gt;&lt;!--wx:if、wx:elif、wx:else 动态的创建和移除元素--&gt;&lt;block wx:if=&quot;&#123;&#123;type===1&#125;&#125;&quot;&gt;    &lt;!--flag是一个布尔值，ture会隐藏元素 hidden只是给元素加上display样式 --&gt;    &lt;view hidden=&quot;&#123;&#123;flag&#125;&#125;&quot;&gt;&lt;/view&gt;&lt;/block&gt;</code></pre><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><pre><code class="hljs vue">&lt;!--wx:for根据index和item来循环渲染数组，可以用-index -item来指定循环变量的名称--&gt;&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;index&quot; wx:for-item= &quot;item&quot;&gt;  索引：&#123;&#123;index&#125;&#125;  当前项:&#123;&#123;item&#125;&#125;&lt;/view&gt;&lt;!--建议使用wx:key来渲染，效率更高。--&gt;&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:key=&quot;id&quot; wx:for-item= &quot;item&quot;&gt;  &#123;&#123;item.name&#125;&#125;&lt;/view&gt;</code></pre><h4 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h4><p>WXSS具有大部分的css特性，同时进行了扩充和修改。</p><ul><li><p>rpx，将一个屏幕等分为750份。</p></li><li><p>@import 后跟需要导入的样式表。</p></li><li><p>在app.wxss中的样式就是全局样式。</p></li></ul><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><ul><li><p>window配置项:在app.json\window\中可以修改导航栏相关设置</p></li><li><p>开启下拉刷新:在app.json\window\中设置 <code>&quot;enablePullDownRefresh&quot;: true</code></p></li><li><p>tabBar配置项：</p></li></ul><pre><code class="hljs vue">//用于设置屏幕底端的导航页，最少2个生效&quot;tabBar&quot;: &#123;    &quot;list&quot;: [      &#123;        &quot;pagePath&quot;: &quot;pages/list/list&quot;,        &quot;text&quot;: &quot;list&quot;&#125;,      &#123;         &quot;pagePath&quot;: &quot;pages/index/index&quot;,        &quot;text&quot;: &quot;index&quot;&#125;]&#125;</code></pre><h3 id="网络数据请求"><a href="#网络数据请求" class="headerlink" title="网络数据请求"></a>网络数据请求</h3><ul><li><p>出于安全考虑只能请求HTTPS类型的接口</p></li><li><p>必须将接口的域名添加到信任列表中（在微信小程序管理后台的开发设置中）</p><h4 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h4><pre><code class="hljs vue">wx.request(&#123;      url: &#x27;url&#x27;,      method:&#x27;GET&#x27;,      data:&#123;        name:&#x27;&#x27;,        texrt:&#x27;&#x27;      &#125;,      success:(res)=&gt;&#123;        console.log(res);      &#125;&#125;)</code></pre></li><li><p>跳过request合法域名校验：详情&#x2F;本地设置中选中不校验，只在开发阶段有用。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事件监听API&quot;&gt;&lt;a href=&quot;#事件监听API&quot; class=&quot;headerlink&quot; title=&quot;事件监听API&quot;&gt;&lt;/a&gt;事件监听API&lt;/h3&gt;&lt;p&gt;以on开头，用来监听某些事件的触发。&lt;/p&gt;
&lt;h3 id=&quot;同步API&quot;&gt;&lt;a href=&quot;#同步</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue路由守卫</title>
    <link href="http://example.com/2023/05/08/Vue%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/"/>
    <id>http://example.com/2023/05/08/Vue%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB/</id>
    <published>2023-05-08T03:16:29.470Z</published>
    <updated>2023-05-08T14:36:22.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前置路由守卫与后置路由守卫"><a href="#前置路由守卫与后置路由守卫" class="headerlink" title="前置路由守卫与后置路由守卫"></a>前置路由守卫与后置路由守卫</h3><pre><code class="hljs vue">const router = new VueRouter(&#123;  routes: [&#123;    path: &quot;/Home&quot;,    component: Home,    meta: &#123; title: &quot;主页&quot; &#125;,    children: [      &#123;        path: &quot;message&quot;,        component: message,        meta: &#123; isAuth: true, title: &quot;消息&quot; &#125;...-------------------------------------------------// 前置路由守卫，切换路由时触发。router.beforeEach((to, from, next) =&gt; &#123;  if (to.meta.isAuth === true) &#123; //筛选需要鉴权的路由//通过token判断权限，next()放行    if (localStorage.getItem(&#x27;school&#x27;) === &#x27;qinchuan&#x27;) &#123; next() &#125;    else &#123;      alert(&#x27;该学校无权限&#x27;)&#125;&#125;  else &#123;next()&#125;&#125;)// 后置路由守卫，切换路由之后被调用router.afterEach((to) =&gt; &#123;  document.title = to.meta.title//在后置路由中判断title的变化&#125;)export default router;//暴露路由</code></pre><h3 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h3><pre><code class="hljs vue">  beforeEnter: (to, from,next)=&gt; &#123;  if (to.meta.isAuth === true) &#123;    if (localStorage.getItem(&#x27;school&#x27;) === &#x27;qinchuan&#x27;) &#123; next() &#125;    else &#123;      alert(&#x27;该学校无权限&#x27;)    &#125;  &#125;  else &#123;    next()  &#125;&#125;,</code></pre><h3 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h3><pre><code class="hljs vue">// 通过路由规则进入该组件时调用  beforeRouteEnter(to, from, next) &#123; &#125;,  // 通过路由规则离开该组件时调用  beforeRouteLeave(to, from, next) &#123; &#125;,</code></pre><h3 id="history模式和hash模式"><a href="#history模式和hash模式" class="headerlink" title="history模式和hash模式"></a>history模式和hash模式</h3><ol><li><p>对于一个url来说#及其后面的内容就是hash值。</p></li><li><p>hash值不会包含在HTTP请求中，即hash值不会带给服务器。</p></li><li><p>hash模式：</p><ol><li>地址中永远带着#号，不美观。</li></ol><p>2）若以后将地址通过第三方APP分享，若校验严格可能显示不合法。</p><p>3）兼容性较好。</p></li><li><p>history模式：</p><p>1）地址干净美观。</p><p>2）兼容性比hash略差。</p><p>3）应用部署上线时需要后端人员支持，解决刷新页面404的问题。</p><pre><code class="hljs vue">index.jsconst router = new VueRouter(&#123;  mode:&quot;history&quot;,// 设置history模式  routes: [&#123;    path: &quot;/Home&quot;,    component: Home......</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前置路由守卫与后置路由守卫&quot;&gt;&lt;a href=&quot;#前置路由守卫与后置路由守卫&quot; class=&quot;headerlink&quot; title=&quot;前置路由守卫与后置路由守卫&quot;&gt;&lt;/a&gt;前置路由守卫与后置路由守卫&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;hljs vue&quot;&gt;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vue路由</title>
    <link href="http://example.com/2023/05/03/Vue%E8%B7%AF%E7%94%B1/"/>
    <id>http://example.com/2023/05/03/Vue%E8%B7%AF%E7%94%B1/</id>
    <published>2023-05-03T06:28:45.046Z</published>
    <updated>2023-05-08T03:16:52.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由是一组映射关系（key—value）,key是路径，value是组件或者函数。</p><h3 id="路由的分类"><a href="#路由的分类" class="headerlink" title="路由的分类"></a>路由的分类</h3><ol><li><p>后端路由：</p><ul><li>理解：value是函数，用于处理客户端的请求。</li><li>工作过程：服务器收到请求后，根据请求路径来匹配函数处理请求，返回响应数据。</li></ul></li><li><p>前端路由：</p><ul><li><p>理解：value是组件，用于展示页面。</p></li><li><p>工作过程：当浏览器改变路径时，显示对应组件。</p></li></ul></li></ol><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><pre><code class="hljs vue">安装vue-routernpm i vue-router@版本号-------------router/index.jsimport VueRouter from &quot;vue-router&quot;;import Home from &quot;@/components/Home.vue&quot;;&lt;!-- 配置路由组件 --&gt;export default new VueRouter(&#123;  routes: [&#123;    path: &quot;/Home&quot;,    component: Home，//子路由children: [&#123;//可以添加name属性简化路由        path: &quot;news&quot;,        component: news&#125;]&#125;]&#125;)---------------main.jsimport VueRouter from &quot;vue-router&quot;;import router from &quot;./router&quot;;&lt;!-- 导入router组件 --&gt;Vue.use(VueRouter)new Vue(&#123;  render: (h) =&gt; h(App),  router: router,&#125;).$mount(&quot;#app&quot;);---------------App.vue&lt;!-- 切换路由链接 --&gt;&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;About&quot;&gt;About&lt;/router-link&gt;&lt;!-- 二级路由链接 --&gt;&lt;router-link class=&quot;list-group-item&quot; to=&quot;/Home/news&quot;&gt;News&lt;/router-link&gt;&lt;!-- 要展示的区域 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;!-- 接收参数 --&gt;this.$route</code></pre><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><pre><code class="hljs vue">&lt;!--1.query参数--&gt;&lt;!-- to的字符串写法 不推荐 --&gt;&lt;router-link :to=&quot;`/Home/message/detail?id=$&#123;mes.id&#125;&amp;title=$&#123;mes.title&#125;`&quot;&gt;    &#123;&#123; mes.title &#125;&#125;&lt;/router-link&gt; &lt;!-- to的对象写法 推荐 --&gt;&lt;router-link :to=&quot;&#123;// 可以添加name:属性简化路由        path: &#x27;/Home/message/detail&#x27;,        query: &#123; id: mes.id, title: mes.title &#125;&#125;&quot;&gt;&#123;&#123; mes.title &#125;&#125;&lt;/router-link&gt;--------------------&lt;!--1.params参数--&gt;&lt;router-link :to=&quot;`/Home/message/detail/$&#123;mes.id&#125;/$&#123;mes.title&#125;`&quot;&gt;&#123;&#123; mes.title &#125;&#125;&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &#x27;detail&#x27;,       params: &#123; id: mes.id, title: mes.title &#125;&#125;&quot;&gt;&#123;&#123; mes.title &#125;&#125;&lt;/router-link&gt;&lt;!-- 接收参数 --&gt;this.$route.&lt;li&gt;消息编号：&#123;&#123; $route.params.id &#125;&#125;&lt;/li&gt;&lt;li&gt;消息编号：&#123;&#123; $route.query.id &#125;&#125;&lt;/li&gt;&lt;!-- params路由特别设置 --&gt;children: [&#123;name: &quot;detail&quot;,            path: &quot;detail/:id/:title&quot;,            component: detail&#125;</code></pre><h3 id="props配置"><a href="#props配置" class="headerlink" title="props配置"></a>props配置</h3><pre><code class="hljs vue">children: [&#123;name: &quot;detail&quot;,            path: &quot;detail/:id/:title&quot;,            component: detail,            // 固定参数，对象中的所有参数都会以props形式传给detail组件            // props: &#123;a: 1, b: &#x27;hello&#x27;&#125;            // 若为true,会把所有收到的params以props形式传给detail组件            // props: true            // 回调函数写法,适用query            props($router) &#123;              return &#123;                id: $router.query.id,                title: $router.query.title&#125;&#125;&#125;]</code></pre><h3 id="router-link的属性"><a href="#router-link的属性" class="headerlink" title="router-link的属性"></a>router-link的属性</h3><pre><code class="hljs vue">1. router-link有两个属性，push和replace.2. push是追加历史记录，replace是替换当前记录，默认为push。3.设置属性：&lt;router-link replace&gt;&lt;/router-link&gt;</code></pre><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><pre><code class="hljs vue">//router的两个AIPpushShow(mes) &#123;      this.$router.push(&#123;        name: &#x27;detail&#x27;,        query: &#123; id: mes.id, title: mes.title &#125;      &#125;)    &#125;,    replaceShow(mes) &#123;      this.$router.replace(&#123;        name: &#x27;detail&#x27;,        query: &#123; id: mes.id, title: mes.title &#125;      &#125;)    &#125;this.$router.back()// 后退this.$router.forward()//前进this.$router.go(3)//go(正数前脚，负数后退)</code></pre><h3 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h3><pre><code class="hljs vue">&lt;!-- 保持挂载不被销毁  include用于指定缓存的组件，默认是全部子组件 --&gt;&lt;keep-alive include=&quot;news&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;</code></pre><h3 id="有关路由的生命周期钩子"><a href="#有关路由的生命周期钩子" class="headerlink" title="有关路由的生命周期钩子"></a>有关路由的生命周期钩子</h3><pre><code class="hljs vue">//组件激活时触发activated()     //组件失活时触发                           deactivated()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;路由&quot;&gt;&lt;a href=&quot;#路由&quot; class=&quot;headerlink&quot; title=&quot;路由&quot;&gt;&lt;/a&gt;路由&lt;/h3&gt;&lt;p&gt;路由是一组映射关系（key—value）,key是路径，value是组件或者函数。&lt;/p&gt;
&lt;h3 id=&quot;路由的分类&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/2023/04/26/%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2023/04/26/%E6%95%B0%E7%BB%84/</id>
    <published>2023-04-26T14:17:12.336Z</published>
    <updated>2023-04-26T15:30:46.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是数据的集合</p><h3 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h3><ul><li>number&#x2F;</li></ul><h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><pre><code class="hljs javascript"><span class="hljs-comment">//创建数组</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<span class="hljs-comment">//另一种方式:let arr = new Array(1,2,3)</span><span class="hljs-comment">//常用的方法</span>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<span class="hljs-comment">// 添加到最后一个元素</span>arr.<span class="hljs-title function_">pop</span>(<span class="hljs-number">4</span>) <span class="hljs-comment">// 删除最后一个元素</span>arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//添加到第一个元素</span>arr.<span class="hljs-title function_">shift</span>()<span class="hljs-comment">//删除第一个元素</span>arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<span class="hljs-comment">//从第0个开始，删去2个元素,在删除的位置加一个元素：4</span>arr.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">x, y</span>)=&gt;</span>x - y)<span class="hljs-comment">//数组自带的排序，x-y正序，y-x逆序。</span>arr.<span class="hljs-title function_">concat</span>(arr2)<span class="hljs-comment">//连接2个数组</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;p&gt;数组是数据的集合&lt;/p&gt;
&lt;h3 id=&quot;数组的分类&quot;&gt;&lt;a href=&quot;#数组的分类&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vuex</title>
    <link href="http://example.com/2023/04/24/vuex/"/>
    <id>http://example.com/2023/04/24/vuex/</id>
    <published>2023-04-24T12:24:06.456Z</published>
    <updated>2023-05-04T03:33:04.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="Vuex的组成"><a href="#Vuex的组成" class="headerlink" title="Vuex的组成"></a>Vuex的组成</h3><p>vuex由三个核心部分组成，本质都是对象，通过store管理：</p><p>actions: 用于响应组件中的动作。</p><p>mutations:用于操作数据（state)。</p><p>state:保存数据并且重新渲染到VC。</p><h3 id="vuex的安装和搭建"><a href="#vuex的安装和搭建" class="headerlink" title="vuex的安装和搭建"></a>vuex的安装和搭建</h3><pre><code class="hljs vue">npm i vuex@版本号 //vue2安装vuex@3 vue3安装vuex4--------index.js   //用于创建Vuex中的store。import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex);const state = &#123;  sum: 0,&#125;;const actions = &#123;  // 业务逻辑写这里  addOdd(conxtext, value) &#123;    if (conxtext.state.sum % 2) &#123;      conxtext.commit(&quot;Add&quot;, value);    &#125;&#125;,  addWait(conxtext, value) &#123;    setTimeout(() =&gt; &#123;      conxtext.commit(&quot;Add&quot;, value);    &#125;, 500);  &#125;,&#125;;const mutations = &#123;  // 数据加工写这里  Add(state, value) &#123;    state.sum += value;  &#125;,  DEC(state, value) &#123;    state.sum -= value;  &#125;,&#125;;export default new Vuex.Store(&#123;  state,  getters: &#123;&#125;,  actions,  mutations,  modules: &#123;&#125;,&#125;);------组件中methods: &#123;    incerment() &#123;      // 没有业务逻辑直接commit与mutations对话      this.$store.commit(&quot;Add&quot;, this.number);    &#125;,    decerment() &#123;      this.$store.commit(&quot;DEC&quot;, this.number);    &#125;,    // 有业务逻辑dispatch()与actions对话    incermentOdd() &#123;      this.$store.dispatch(&quot;addOdd&quot;, this.number);    &#125;,    incermentWait() &#123;      this.$store.dispatch(&quot;addWait&quot;, this.number);    &#125;,&#125;,//读取Vuex中的数据this.$store.state.sum</code></pre><h4 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h4><pre><code class="hljs vue">//将state中的数据进行加工//可以优化成mapGetters &lt;h3&gt;当前求和为：&#123;&#123; $store.getters.bigSum &#125;&#125;&lt;/h3&gt;-----------const getters = &#123;  bigSum() &#123;    return state.sum * 10;  &#125;,&#125;;</code></pre><h4 id="map方法的使用"><a href="#map方法的使用" class="headerlink" title="map方法的使用"></a>map方法的使用</h4><pre><code class="hljs vue">MyCount.vue&lt;h1&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h1&gt;&lt;h3&gt;当前求和为：&#123;&#123; bigSum &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;incerment(number)&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;incermentOdd(number)&quot;&gt;当前求和为奇数再加&lt;/button&gt;----------computed: &#123;// 对象写法，会调dispatch ...mapActions(&#123; incermentOdd: &quot;addOdd&quot;, incermentWait: &quot;addWait&quot; &#125;),    // 从state中取数据    ...mapState(&#123; sum: &quot;sum&quot; &#125;),//方法会调用commit ...mapMutations(&#123; incerment: &quot;Add&quot;, decerment: &quot;DEC&quot; &#125;),    //数组写法,要和index中的方法同名，@click方法中名字也要同名。...mapActions(&#123;[&quot;addOdd&quot;,&quot;addWait&quot;]),    ...mapState([&quot;sum&quot;]), ...mapGetters([&quot;bigSum&quot;]),//方法会调用commit ...mapMutations([&quot;Add&quot;, &quot;DEC&quot;]),  &#125;,&#125;;----------index.js同上</code></pre><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><pre><code class="hljs vue">当我们有2个组件时，可以通过 ...mapState([&quot;sum&quot;]),来共享数据。--------MyPerson.vue&lt;h3&gt;下方求和为&#123;&#123; sum &#125;&#125;&lt;/h3&gt;-----computed: &#123;    ...mapState([&quot;personList&quot;, &quot;sum&quot;]),  &#125;,</code></pre><h3 id="Vuex-模块化"><a href="#Vuex-模块化" class="headerlink" title="Vuex 模块化"></a>Vuex 模块化</h3><pre><code class="hljs vue">可以创建多个options来分管不同模块index.js//求和模块const countOptins = &#123;//开启命名空间  namespaced: true,  state: &#123;    sum: 0,  &#125;,//人数模块const personOptins = &#123;  namespaced: true,  state: &#123;    personList: [      &#123;        id: &quot;001&quot;,        name: &quot;张三&quot;,      &#125;,],&#125;,-------------Mycoun.vue//简写引入形式，其他同state...mapState(&quot;countOptins&quot;, [&quot;sum&quot;]),...mapState(&quot;personOptins&quot;, [&quot;personList&quot;]),//直接读取形式//statethis.$store.state.countOptins.sum//mutationsthis.$store.commit(&quot;personOptins/AddPERSON&quot;, PersonObj);//getterthis.$store.getter(&quot;personOptins/AddPerson&quot;, PersonObj);//actionsthis.$store.dispatch(&quot;personOptins/AddPerson&quot;, PersonObj);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vuex&quot;&gt;&lt;a href=&quot;#Vuex&quot; class=&quot;headerlink&quot; title=&quot;Vuex&quot;&gt;&lt;/a&gt;Vuex&lt;/h2&gt;&lt;h3 id=&quot;Vuex的组成&quot;&gt;&lt;a href=&quot;#Vuex的组成&quot; class=&quot;headerlink&quot; title=&quot;Vue</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue插槽</title>
    <link href="http://example.com/2023/04/24/vue%E6%8F%92%E6%A7%BD/"/>
    <id>http://example.com/2023/04/24/vue%E6%8F%92%E6%A7%BD/</id>
    <published>2023-04-24T07:57:52.802Z</published>
    <updated>2023-04-24T11:58:23.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue插槽"><a href="#vue插槽" class="headerlink" title="vue插槽"></a>vue插槽</h2><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件到子组件。</p><p>分类如下：</p><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><pre><code class="hljs vue">父组件：&lt;子组件名称&gt;&lt;div&gt;html结构&lt;/div&gt;    &lt;/子组件名称&gt;子组件：插槽等着组件的使用者进行填充&lt;slot&gt;可以写一个默认值，当使用者没有传递具体结构时出现&lt;/slot&gt;</code></pre><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><pre><code class="hljs vue">父组件：&lt;div slot=&#x27;center&#x27;&gt;    &lt;img&gt;&lt;/div&gt;//v-slot只能用在模板标签里&lt;template V-slot:center&gt;    &lt;img&gt;&lt;/template&gt;&lt;template slot=&#x27;center&#x27;&gt;    &lt;img&gt;&lt;/template&gt;------------子组件：&lt;slot name = center&gt;&lt;/slot&gt;可以写一个默认值，当使用者没有传递具体结构时出现&lt;/slot&gt;</code></pre><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>数据在插槽组件自身，数据的呈现形式则由插槽使用者来决定。</p><pre><code class="hljs vue">&lt;Category&gt;&lt;template slot-scope=&quot;scopeData&quot;&gt;    &lt;ul&gt;       &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/template&gt;//&#123;&#123;解构赋值&#125;&#125;，否则要加上组件名&lt;template slot-scope=&quot;&#123;&#123;games&#125;&#125;&quot;&gt;     &lt;ol&gt;        &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&lt;/li&gt;    &lt;/ol&gt;&lt;/template&gt;&lt;/Category&gt;------------&lt;template&gt;&lt;div&gt;    &lt;slot :games =&quot;games&quot;&gt;&lt;/slot&gt;默认值&lt;/slot&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123;    name:&quot;Category&quot;,    props:[&#x27;title&#x27;],    data()&#123;return&#123;games:[&#x27;q&#x27;,&#x27;w&#x27;]&#125;    &#125;,&#125;&lt;/script&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue插槽&quot;&gt;&lt;a href=&quot;#vue插槽&quot; class=&quot;headerlink&quot; title=&quot;vue插槽&quot;&gt;&lt;/a&gt;vue插槽&lt;/h2&gt;&lt;p&gt;作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件到子组件。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue解决跨域问题</title>
    <link href="http://example.com/2023/04/23/vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/04/23/vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-23T01:11:14.226Z</published>
    <updated>2023-05-04T03:33:26.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue解决跨域问题"><a href="#vue解决跨域问题" class="headerlink" title="vue解决跨域问题"></a>vue解决跨域问题</h2><h3 id="使用vue-cli建立代理服务器"><a href="#使用vue-cli建立代理服务器" class="headerlink" title="使用vue-cli建立代理服务器"></a>使用vue-cli建立代理服务器</h3><p>方式一：</p><p>缺点：不能灵活控制是否使用代理，不能配置多个代理</p><pre><code class="hljs vue">Vue.config.js文件const &#123; defineConfig &#125; = require(&quot;@vue/cli-service&quot;);module.exports = defineConfig(&#123;  transpileDependencies: true,  lintOnSave: false,//配置devServer:&#123;proxy:&#x27;http://localhost:服务器转发端口号&#x27;&#125;&#125;);</code></pre><p>方式二：</p><pre><code class="hljs vue">devServer:&#123;proxy:&#123;//&#x27;请求的前缀&#x27;&#x27;/api&#x27;:&#123;//端口号target:&#x27;&lt;url&gt;&#x27;,    //重写路径，去掉请求前缀    pathRewirte:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125;    //用于支持websocket    ws:true,    changeOrigin:true&#125;,    &#x27;/foo&#x27;:&#123;        target:&#x27;&lt;other_url&gt;&#x27;        &#125;&#125;&#125;配置后在端口号前面加上请求前缀</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue解决跨域问题&quot;&gt;&lt;a href=&quot;#vue解决跨域问题&quot; class=&quot;headerlink&quot; title=&quot;vue解决跨域问题&quot;&gt;&lt;/a&gt;vue解决跨域问题&lt;/h2&gt;&lt;h3 id=&quot;使用vue-cli建立代理服务器&quot;&gt;&lt;a href=&quot;#使用vue-cli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue事件总线</title>
    <link href="http://example.com/2023/04/22/vue%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"/>
    <id>http://example.com/2023/04/22/vue%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/</id>
    <published>2023-04-22T14:09:33.821Z</published>
    <updated>2023-05-04T03:33:38.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue全局事件总线（GlobalEvenBus）"><a href="#vue全局事件总线（GlobalEvenBus）" class="headerlink" title="vue全局事件总线（GlobalEvenBus）"></a>vue全局事件总线（GlobalEvenBus）</h3><ol><li><p>一种组件间通信的方式，适用于任意组件间通信</p></li><li><p>安装全局事件总线：</p><pre><code class="hljs vue">new Vue(&#123;......beforeCreate()&#123;Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm&#125;，......&#125;)</code></pre></li><li><p>使用事件总线：</p><ol><li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。</p><pre><code class="hljs vue">methods()&#123;demo(data)&#123;......&#125;&#125;mouted()&#123;this.$bus.$on(&#x27;xxx&#x27;,this.demo)&#125;</code></pre></li><li><p>提供数据：<code>this.$bus.$emit(&#39;xxx&#39;,数据)</code></p></li></ol></li><li><p>最好在beforeDestory钩子中，用$off去解绑当前组件用到的事件。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue全局事件总线（GlobalEvenBus）&quot;&gt;&lt;a href=&quot;#vue全局事件总线（GlobalEvenBus）&quot; class=&quot;headerlink&quot; title=&quot;vue全局事件总线（GlobalEvenBus）&quot;&gt;&lt;/a&gt;vue全局事件总线（Glob</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VUE自定义组件</title>
    <link href="http://example.com/2023/04/22/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2023/04/22/vue%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6/</id>
    <published>2023-04-22T12:15:00.126Z</published>
    <updated>2023-04-22T12:29:42.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h3><ol><li><p>自定义事件是一种组件间通信的方式，适用于：子组件&#x3D;&#x3D;》父组件。</p></li><li><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调函数在A中）。</p></li><li><p>绑定自定义事件</p><ol><li><p>第一种方式：在父组件中：  <code>&lt;Demo @自定义事件名=“自定义函数名&gt; </code>或<code>&lt;Demo v-on:自定义事件名=“自定义函数名&gt; </code>。</p></li><li><p>第二种方式：在父组件中：</p><pre><code class="hljs vue">&lt;Demo res=&quot;demo&quot;/&gt;---------------------mounted()&#123;this.$refs.xxx.$on(&#x27;自定义事件名&#x27;，this.自定义函数名)&#125;</code></pre></li><li><p>若想让自定义事件只触发一次可以用<code>once</code>修饰符或<code>$once</code>方法。</p></li></ol></li><li><p>触发自定义事件：<code>this.$emit(&#39;自定义事件名&#39;，数据)</code>。</p></li><li><p>解绑自定义事件：<code>this.$off(&#39;自定义事件名&#39;)</code>。</p></li><li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p></li><li><p>注意：通过<code>this.$refs.xxx.$on(&#39;自定义事件名&#39;,回调)</code>绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;组件的自定义事件&quot;&gt;&lt;a href=&quot;#组件的自定义事件&quot; class=&quot;headerlink&quot; title=&quot;组件的自定义事件&quot;&gt;&lt;/a&gt;组件的自定义事件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自定义事件是一种组件间通信的方式，适用于：子组件&amp;#x3D;&amp;#x3D;》</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue配置项</title>
    <link href="http://example.com/2023/04/16/Vue%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
    <id>http://example.com/2023/04/16/Vue%E9%85%8D%E7%BD%AE%E9%A1%B9/</id>
    <published>2023-04-16T13:03:32.739Z</published>
    <updated>2023-04-16T15:02:00.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue配置项"><a href="#vue配置项" class="headerlink" title="vue配置项"></a>vue配置项</h3><h5 id="props-配置项"><a href="#props-配置项" class="headerlink" title="props 配置项"></a>props 配置项</h5><p>​功能：让组件接收外部传来的数据。props是只读的，如果进行修改，会收到警告，可以把props复制一份到data中，然后修改data。</p><pre><code class="hljs vue">1.传递数据：&lt;Demo name=&quot;xxx&quot;/&gt;2.接收数据：props:[&#x27;name&#x27;]//只接收数据props:&#123;name:Number&#125;//限制接收数据的类型props:&#123;name:&#123;type:String,//类型required:true,//必要性default:&#x27;老王&#x27;//默认值&#125;&#125;</code></pre><h5 id="mixmin-混入"><a href="#mixmin-混入" class="headerlink" title="mixmin 混入"></a>mixmin 混入</h5><p>​功能：可以把多个组件共用的配置提取成一个混入对象</p><p>​使用方式:</p><pre><code class="hljs vue">1.定义混合：export const xxx =&#123;data()&#123;...&#125;,methods:&#123;...&#125;,...&#125;2.使用混入：使用import引入文件中然后：(1)全局混入：vue.mixin(xxx)(2)局部混入：mixins:[&#x27;xxx&#x27;]</code></pre><h5 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h5><p>功能：用于增强vue，本质是包含install方法的对象，install的第一个参数是vue,第二个参数是使用者传递的数据。</p><pre><code class="hljs vue">1.定义插件：对象.install= function(Vue,options)&#123;Vue.filter(...)Vue.directive(...)Vue.mixin(...)&#125;2.引用插件：VUe,use()</code></pre><h5 id="scoped样式属性"><a href="#scoped样式属性" class="headerlink" title="scoped样式属性"></a>scoped样式属性</h5><p>功能：让样式在局部生效防止冲突</p><pre><code class="hljs vue">&lt;style scoped&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue配置项&quot;&gt;&lt;a href=&quot;#vue配置项&quot; class=&quot;headerlink&quot; title=&quot;vue配置项&quot;&gt;&lt;/a&gt;vue配置项&lt;/h3&gt;&lt;h5 id=&quot;props-配置项&quot;&gt;&lt;a href=&quot;#props-配置项&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue脚手架配置</title>
    <link href="http://example.com/2023/04/16/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/04/16/vue%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE/</id>
    <published>2023-04-16T02:16:49.091Z</published>
    <updated>2023-04-16T09:10:04.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初始化脚手架"><a href="#初始化脚手架" class="headerlink" title="初始化脚手架"></a>初始化脚手架</h4><pre><code class="hljs plaintext">1.全局安装脚手架npm install -g @vue/cli2.切换到要创建项目的目录后创建项目vue create 项目名称3.启动项目npm run serve配置国内镜像：npm config set registryhttps://registry.npm.taobao.org查询webpack相关配置：vue inspect &gt; output.js</code></pre><h4 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h4><p>public:index.html、icoy页签图标和主页面</p><p>src:</p><ul><li>assets：存放静态资源</li><li>component:存放组件</li><li>app.vue：汇总组件</li><li>main.js:入口文件</li><li>packag-lock.json:包版本控制文件</li><li>vue.config.js:脚手架配置文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初始化脚手架&quot;&gt;&lt;a href=&quot;#初始化脚手架&quot; class=&quot;headerlink&quot; title=&quot;初始化脚手架&quot;&gt;&lt;/a&gt;初始化脚手架&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;hljs plaintext&quot;&gt;1.全局安装脚手架
npm install -</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VUE组件的基本结构</title>
    <link href="http://example.com/2023/04/14/vue%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2023/04/14/vue%E7%BB%84%E4%BB%B6/</id>
    <published>2023-04-14T07:31:44.320Z</published>
    <updated>2023-05-04T03:34:29.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h3><p>组件可以解决传统开发中文件依赖不容易维护，可能发生冲突的问题。同时可以增加代码的复用率。</p><p>组件是用来实现局部（特定）功能的代码集合。</p><p>实际开发中由vm管理app组件，app组件嵌套其他所有组件。</p><h4 id="非单文件组件"><a href="#非单文件组件" class="headerlink" title="非单文件组件"></a>非单文件组件</h4><pre><code class="hljs vue">&lt;body&gt;  &lt;div id=&quot;root&quot;&gt;    &lt;school&gt;&lt;/school&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script&gt;  const school = Vue.extend(&#123;    template: `      &lt;div&gt;        &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt;        &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;      &lt;/div&gt;`,    data() &#123;      return &#123;        schoolName: &#x27;上鬼狐&#x27;,        address: &#x27;北京昌平&#x27;      &#125;&#125;&#125;)  new Vue(&#123;    el: &#x27;#root&#x27;,    components: &#123;      school,      student    &#125;&#125;)&lt;/script&gt;</code></pre><h4 id="VueComponent构造函数"><a href="#VueComponent构造函数" class="headerlink" title="VueComponent构造函数"></a>VueComponent构造函数</h4><p>组件本质是一个VueComponent构造函数，Vue解析的时候会帮我们创建组件同名的构造函数。每次调用Vue.extend返回的都是一个全新的VueComponent。</p><h5 id="关于this的指向"><a href="#关于this的指向" class="headerlink" title="关于this的指向"></a>关于this的指向</h5><ul><li><p>组件配置中：data、methods、watch、computed中的函数均指向【VueComponent】</p></li><li><p>new Vue()中：data、methods、watch、computed中的函数均指向【Vue实例对象（vm）】</p></li><li><p>VueComponent有的功能vm都有，但是vm可以绑定el。</p></li><li><p>VueComponent.prototype.<strong>proto</strong>&#x3D;&#x3D;&#x3D;Vue.prototype</p></li></ul><h4 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h4><p>一个单文件组件包含一下结构：</p><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;     &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    import 其他组件 from &#x27;url&#x27;//不必要    export default&#123;        name:&#x27;组件名称&#x27;,        components:&#123;&#125;,//不必要        data()&#123;            retun&#123;&#125;        &#125;,        methods:&#123;&#125;    &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><p>所有的组件都遵从vm的管理，我们用main.js来管理</p><pre><code class="hljs vue">import App from &#x27;url&#x27;new Vue(&#123;el:&#x27;#容器id&#x27;, components:&#123;APP&#125;&#125;)</code></pre><p>我们还需要一个index.html文件来做容器</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>只显示了基本结构，删除了无关代码<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!--容器--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue组件&quot;&gt;&lt;a href=&quot;#vue组件&quot; class=&quot;headerlink&quot; title=&quot;vue组件&quot;&gt;&lt;/a&gt;vue组件&lt;/h3&gt;&lt;p&gt;组件可以解决传统开发中文件依赖不容易维护，可能发生冲突的问题。同时可以增加代码的复用率。&lt;/p&gt;
&lt;p&gt;组件是用来实</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VUE生命周期</title>
    <link href="http://example.com/2023/04/13/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2023/04/13/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-04-13T12:39:48.305Z</published>
    <updated>2023-04-14T07:19:13.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VUE生命周期"><a href="#VUE生命周期" class="headerlink" title="VUE生命周期"></a>VUE生命周期</h3><h4 id="挂载流程"><a href="#挂载流程" class="headerlink" title="挂载流程"></a>挂载流程</h4><p>在此之前创建生命周期、事件。</p><ol><li><p>beforeCreate:此时无法通过vm访问到data中的数据，methods中的方法。</p><p>在此之后创建数据检测、数据代理。</p></li><li><p>created:此时可以通过vm访问到data中的数据、methods中的配置的方法。</p></li><li><p>beforeMount：页面未经vue编译的DOM结构，对所有DOM操作最终不生效。（被虚拟dom覆盖了）</p></li><li><p>mounted:页面呈现经过Vue编译的DOM，对DMO的操作均有效但应该避免。至此初始化过程结束，一半在此阶段进行：开启定时器，发送网络请求，订阅消息，绑定自定义事件等初始化操作。</p></li></ol><h4 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h4><ol><li><p>beforUpdate：此时页面和数据尚未保持同步。</p></li><li><p>生成新的虚拟DOM和旧的对比，完成模型到视图的更新。</p></li><li><p>updated：此时页面和数据保持同步.</p></li></ol><h4 id="销毁流程"><a href="#销毁流程" class="headerlink" title="销毁流程"></a>销毁流程</h4><ol><li>beforeDestory:此时，vm中所有的：data、methouds、指令都处于可用状态，马上要执行销毁过程。但不会再触发更新了。一般在这个状态关闭定时器，取消订阅消息，解绑自定义事件。</li><li>destory:销毁vm实例。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;VUE生命周期&quot;&gt;&lt;a href=&quot;#VUE生命周期&quot; class=&quot;headerlink&quot; title=&quot;VUE生命周期&quot;&gt;&lt;/a&gt;VUE生命周期&lt;/h3&gt;&lt;h4 id=&quot;挂载流程&quot;&gt;&lt;a href=&quot;#挂载流程&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Git控制版本</title>
    <link href="http://example.com/2023/04/10/Git/"/>
    <id>http://example.com/2023/04/10/Git/</id>
    <published>2023-04-10T11:42:33.915Z</published>
    <updated>2023-05-04T03:34:02.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git的特性"><a href="#Git的特性" class="headerlink" title="Git的特性"></a>Git的特性</h3><ol><li><p>直接记录快照（在原有基础上重新生成一份新文件)，而非差异比较。</p></li><li><p>几乎所有操作都在本地执行。</p></li><li><p>与SVN的差异：SVN是基于差异的版本控制，他们是储存一组基本文件，随时间逐步累积差异。</p></li></ol><h3 id="Git的基础概念"><a href="#Git的基础概念" class="headerlink" title="Git的基础概念"></a>Git的基础概念</h3><ul><li><p>Git项目管理有三个分区：工作区、暂存区、git仓库。</p></li><li><p>Git的三种状态：已修改（modified）、已暂存（staged）、已提交（committed）</p></li></ul><h4 id="Git的配置信息"><a href="#Git的配置信息" class="headerlink" title="Git的配置信息"></a>Git的配置信息</h4><pre><code class="hljs git">#查看所有的全局配置项git config --list --global#查看指定的全局配置项git config user.name/.email#命令手册git help config</code></pre><h4 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h4><pre><code class="hljs git">#初始化本地仓库1.在项目目录中，右键打开git bash2.执行 git init 命令将当前的目录转化为git仓库（创建隐藏目录.git）#查看命令状态，保存完毕会显示未修改状态，不管理的文件则是未跟踪(Untracked)git status/git -s/git --short(后两者是精简模式)#跟踪新文件/添加修改后的文件git add 文件名 //添加单一文件git add . //添加所有工作区文件添加到暂存区后再使用git status,文件前面会呈现一个绿色的A。修改后未添加的文件使用git status，文件前面会有一个红色的M。#提交文件git commit -m&quot;提交描述信息&quot;提交成功后再次使用git status，显示working tree clean表示成功。#撤销修改（慎重!无法恢复）git checkout --文件名本质上仓库文件直接覆盖#从暂存区里移除文件git reset HEAD 文件名#快速提交到git仓库git commit -a -m &quot;描述消息&quot; 会把之前已经跟踪的文件直接上传到git仓库，跳过暂存区。#从Git仓库和工作区中同时移除文件git rm -f 文件名#只从Git仓库中移除文件，但保留工作区中的文件git rm --cached 文件名#忽略文件创建一个.gitignore文件，格式规范如下：以#开头是注释，以/开头防止递归，以/结尾是目录，以!开头表示取反。#使用glob模式进行文件和文件夹匹配（glob是简化之后的正则表达式）1.*匹配任意字符，（*.a忽略所有.a文件）2.[abc]匹配任何一个列在方括号中的字符（匹配一个a或一个b或一个c）3.?只匹配一个任意字符4.[0-9][a-z]以此类推，匹配范围内的字符5.**匹配任意中间目录（a/**/z，可以匹配a/z、a/b/z等）注意以上匹配在gitignore文件中，满足匹配要求就是被忽略的文件。#查看提交历史git log //按时间顺序列出所有提交历史，最近的排在最上面。git log -2 //只展示最新的两条提交历史，数字可以按需进行填写git log -2 --pretty=oneline //在一行上展示最近两条提交历史信息git log -2 --pretty==format:%h|%an|%ar|%s //同上，但是可以自定义输出%h 简写哈希值%an 作者名字%ar 按时间差显示%s 提交说明#退回到指定版本git log  --pretty=oneline //在一行上展示所有提交历史git reset --hard&lt;CommitID&gt; //根据指定的提交ID回退到指定版本git reflog --pretty=oneline //在旧版本中使用该命令，查看命令操作的历史git reset --hard&lt;CommitID&gt; //再次根据最新的提交ID，跳转到最新的版本</code></pre><h3 id="链接远程仓库"><a href="#链接远程仓库" class="headerlink" title="链接远程仓库"></a>链接远程仓库</h3><h4 id="将本地仓库推送到远程仓库"><a href="#将本地仓库推送到远程仓库" class="headerlink" title="将本地仓库推送到远程仓库"></a>将本地仓库推送到远程仓库</h4><pre><code class="hljs git">#HTTP链接方式git init //初始化git仓库git add README.md //添加说明文档git commit -m &quot;提交信息&quot;git remote add origin（或者其他别名） 远程仓库地址 //给仓库起别名git push -u origin main 推送文件到远程仓库(第一次需要-u后续不需要)若本地已有仓库则执行最后2条代码即可。#SSH链接方式（免登录，加密数据传输）SSH Key包含2个部分： id_rsa(私钥文件，存放在客户端电脑中)id_rsa.pub(公钥文件，需要配置到Github中)#生成SSH key1.打开git bash2.输入命令： ssh-keygen -t rsa -b 4096 -C &quot;邮箱地址&quot;3.连续回车3次，上述key将保存在C:\用户名文件夹\.ssh目录中#配置SSH key1.在id_rsa.pub文件中复制全部内容2.在远程仓库(github等)中SSh设置中命名新的ssh key，并且粘贴复制内容#检测SSH是否配置成功在git bash中输入 ssh -T git@github.com在弹出的对话中输入yes，提示成功即可。#SSH方式上传远程仓库git remote add origin git@github.com:SSH地址git push -u origin main 推送文件到远程仓库#将远程仓库克隆到本地打开git bash输入 git clone 远程仓库地址</code></pre><h4 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h4><p>分支可以避免多人协作开发互相干扰的问题。</p><pre><code class="hljs git">默认分支：main //通常不允许直接在main上修改代码，而是再建一个功能分支。#查看分支列表git branch#创建新分支git branch 分支名称#切换分支git checkout 分支名称git checkout -b 创建并立即切换到新分支#合并分支git checkout main //回到主分支上git merge 分支名 合并分支#删除分支git branch -d 分支名称#查看远程仓库分支git remote show 远程仓库名称#跟踪分支(从远程仓库中把对应的分支下载到本地仓库)git checkout 远程分支名称git checkout -b 本地分支新名称 远程仓库名称/远程分支名称 //重命名本地分支#拉去远程分支新代码git pull#删除远程分支git push origin --delete 远程分支名称#主分支改名//仓库已经初始化但是没有推送git branch -m master main//仓库没有初始化git config --global init.defaultBranch main</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Git的特性&quot;&gt;&lt;a href=&quot;#Git的特性&quot; class=&quot;headerlink&quot; title=&quot;Git的特性&quot;&gt;&lt;/a&gt;Git的特性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接记录快照（在原有基础上重新生成一份新文件)，而非差异比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP协议与跨域</title>
    <link href="http://example.com/2023/04/09/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%B7%A8%E5%9F%9F/"/>
    <id>http://example.com/2023/04/09/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E8%B7%A8%E5%9F%9F/</id>
    <published>2023-04-09T05:00:49.642Z</published>
    <updated>2023-04-12T02:58:55.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同源和跨域的概念"><a href="#同源和跨域的概念" class="headerlink" title="同源和跨域的概念"></a>同源和跨域的概念</h3><p>同源：如果两个页面的协议、域名、端口都相同，则同源。不同源的网页收到浏览器同源策略的影响，不能进行交互。</p><p>跨域：两个URL的协议、域名、端口不一致，出现跨域的根本原因是浏览器同源策略不允许非同源的URL之间进行资源的交互。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>是一种兼容性较好，为了解决跨域问题的临时解决方案，只支持GET请求，不支持POST请求。不是W3C标准。</p><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;#btnJSONP&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        $.<span class="hljs-title function_">ajax</span>(&#123;          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://ajax.frontend.itheima.net:3006/api/jsonp?address=北京&amp;location=顺义&#x27;</span>,          <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,          <span class="hljs-attr">jsonpCallback</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,          <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;&#125;)&#125;)</code></pre><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>出现的比较晚，但是是W3C标准，属于跨域AJAX请求根本解决方案，会替代掉JSONP。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>客户端与服务器之间要实现网页内容的传输，则通信双方必须遵守网页内容传输协议。</p><p>网页内容又叫做超文本，因此也可以叫做超文本传输协议，简称HTTP协议（Hyper Text Transfer Protocol）</p><h4 id="HTTP协议的组成部分"><a href="#HTTP协议的组成部分" class="headerlink" title="HTTP协议的组成部分"></a>HTTP协议的组成部分</h4><p>HTTP协议由请求行，请求头部，空行和请求体组成。</p><ul><li><p>请求行包含：请求方式、URL、协议版本。例如：POST    &#x2F;api&#x2F;post    HTTP&#x2F;1.1</p></li><li><p>请求头部：请求头部由多行 键&#x2F;值对 组成，每行的键和值之间用英文的冒号分隔。</p></li><li><table><thead><tr><th><strong>头部字段</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Host</td><td>要请求的服务器域名</td></tr><tr><td>Connection</td><td>客户端与服务器的连接方式(close  或  keepalive)</td></tr><tr><td>Content-Length</td><td>用来描述请求体的大小</td></tr><tr><td>Accept</td><td>客户端可识别的响应内容类型列表</td></tr><tr><td>User-Agent</td><td>产生请求的浏览器类型</td></tr><tr><td>Content-Type</td><td>客户端告诉服务器实际发送的数据类型</td></tr><tr><td>Accept-Encoding</td><td>客户端可接收的内容压缩编码形式</td></tr><tr><td>Accept-Language</td><td>用户期望获得的自然语言的优先顺序</td></tr></tbody></table></li><li><p>请求体：GET请求没有请求体，只有POST才有。</p></li></ul><p>###HTTP请求方法</p><p>HTTP 请求方法，属于 HTTP 协议中的一部分，请求方法的作用是：用来表明要对服务器上的资源执行的操作。最常用的请求方法是 GET 和 POST。</p><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>GET</td><td>(查询)发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。</td></tr><tr><td>POST</td><td>(新增)向服务器提交资源（例如提交表单或上传文件）。数据被包含在请求体中提交给服务器。</td></tr><tr><td>PUT</td><td>(修改)向服务器提交资源，并使用提交的新资源，替换掉服务器对应的旧资源。</td></tr><tr><td>DELETE</td><td>(删除)请求服务器删除指定的资源。</td></tr></tbody></table><h3 id="HTTP响应状态码"><a href="#HTTP响应状态码" class="headerlink" title="HTTP响应状态码"></a>HTTP响应状态码</h3><p><strong>HTTP</strong> <strong>响应状态码</strong>（HTTP Status Code），也属于 HTTP 协议的一部分，用来标识响应的状态。</p><p>响应状态码会随着响应消息一起被发送至客户端浏览器，浏览器根据服务器返回的响应状态码，就能知道这次 HTTP 请求的结果是成功还是失败了。</p><p>HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字用来对状态码进行细分。</p><p>HTTP 状态码共分为 5 种类型：</p><table><thead><tr><th><strong>分类</strong></th><th><strong>分类描述</strong></th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作（实际开发中很少遇到  1**  类型的状态码）</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h4 id="常见的响应状态码"><a href="#常见的响应状态码" class="headerlink" title="常见的响应状态码"></a>常见的响应状态码</h4><p>#####成功相关的状态码</p><table><thead><tr><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td>200</td><td>OK</td><td>请求成功。一般用于  GET 与 POST  请求</td></tr><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源，通常用于  POST 或 PUT  请求</td></tr></tbody></table><h5 id="重定向相关的状态码"><a href="#重定向相关的状态码" class="headerlink" title="重定向相关的状态码"></a>重定向相关的状态码</h5><table><thead><tr><th><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td>301</td><td>Moved  Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>304</td><td>Not  Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源（响应消息中不包含响应体）。客户端通常会缓存访问过的资源。</td></tr></tbody></table><h5 id="客户端错误相关状态码"><a href="#客户端错误相关状态码" class="headerlink" title="客户端错误相关状态码"></a>客户端错误相关状态码</h5><table><thead><tr><th><strong>状态码</strong></th><th align="left"><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td>400</td><td align="left">Bad  Request</td><td>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。  2、请求参数有误。</td></tr><tr><td>401</td><td align="left">Unauthorized</td><td>当前请求需要用户验证。</td></tr><tr><td>403</td><td align="left">Forbidden</td><td>服务器已经理解请求，但是拒绝执行它。</td></tr><tr><td>404</td><td align="left">Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。</td></tr><tr><td>408</td><td align="left">Request Timeout</td><td>请求超时。服务器等待客户端发送的请求时间过长，超时。</td></tr></tbody></table><h5 id="服务端错误相关状态码"><a href="#服务端错误相关状态码" class="headerlink" title="服务端错误相关状态码"></a>服务端错误相关状态码</h5><table><thead><tr><th align="left"><strong>状态码</strong></th><th><strong>状态码英文名称</strong></th><th><strong>中文描述</strong></th></tr></thead><tbody><tr><td align="left">500</td><td>Internal  Server Error</td><td>服务器内部错误，无法完成请求。</td></tr><tr><td align="left">501</td><td>Not  Implemented</td><td>服务器不支持该请求方法，无法完成请求。只有  GET 和 HEAD  请求方法是要求每个服务器必须支持的，其它请求方法在不支持的服务器上会返回501</td></tr><tr><td align="left">503</td><td>Service  Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;同源和跨域的概念&quot;&gt;&lt;a href=&quot;#同源和跨域的概念&quot; class=&quot;headerlink&quot; title=&quot;同源和跨域的概念&quot;&gt;&lt;/a&gt;同源和跨域的概念&lt;/h3&gt;&lt;p&gt;同源：如果两个页面的协议、域名、端口都相同，则同源。不同源的网页收到浏览器同源策略的影响，不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>XML和JSON</title>
    <link href="http://example.com/2023/04/06/XML%E5%92%8CJSON/"/>
    <id>http://example.com/2023/04/06/XML%E5%92%8CJSON/</id>
    <published>2023-04-06T07:26:35.709Z</published>
    <updated>2023-04-12T02:59:58.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XML和JSON"><a href="#XML和JSON" class="headerlink" title="XML和JSON"></a>XML和JSON</h2><ul><li>XML和JSON都是数据传输与交换的格式，现在常用的是JSON格式。</li><li>XML和HTML类似，都是标记语言，。区别是XML不是网页载体而是数据载体。缺点是在JS中解析不方便，体积大，标签多，效率低。</li><li>JSON：JS对象表示法，使用文本表示JS对象，本质就是字符串。比XML更小、更快、更好解析。</li></ul><h3 id="JSON的两种结构"><a href="#JSON的两种结构" class="headerlink" title="JSON的两种结构"></a>JSON的两种结构</h3><ul><li>对象结构</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">//&#123;key:value&#125;其中key必须用英文双引号包裹的字符串，value的数据类型可以是数字、字符串、布尔值、null、数组、对象6种类型。</span>&#123;    <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;xiaoli&quot;</span>,    <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">20</span>,    <span class="hljs-string">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>,    <span class="hljs-string">&quot;address&quot;</span>: <span class="hljs-literal">null</span>,    <span class="hljs-string">&quot;hobby&quot;</span>:[<span class="hljs-string">&quot;唱歌&quot;</span>,<span class="hljs-string">&quot;打游戏&quot;</span>,<span class="hljs-string">&quot;编程&quot;</span>]    &#125;</code></pre><p>注意事项：</p><ol><li>属性名必须双引号包裹。</li><li>字符串类型必须双引号包裹。</li><li>JSON中不允许使用单引号表示字符串。</li><li>JSON中不能写注释。</li><li>JSON的最外层必须是对象或者数组格式。</li><li>不能使用undefined或函数作为JSON的值。</li><li>使用JSON.parse()把JSON转换成JS对象（反序列化）。</li><li>JS转换成JSON使用JSON.stringify()（序列化）。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XML和JSON&quot;&gt;&lt;a href=&quot;#XML和JSON&quot; class=&quot;headerlink&quot; title=&quot;XML和JSON&quot;&gt;&lt;/a&gt;XML和JSON&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;XML和JSON都是数据传输与交换的格式，现在常用的是JSON格式。&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>xhrHttp的基本使用</title>
    <link href="http://example.com/2023/04/06/xhrHttp%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/04/06/xhrHttp%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-06T05:42:24.855Z</published>
    <updated>2023-04-12T02:59:50.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xhrHttp的基本使用"><a href="#xhrHttp的基本使用" class="headerlink" title="xhrHttp的基本使用"></a>xhrHttp的基本使用</h1><p>xhr是最基础的数据交互方法，通常不会去使用，了解即可。</p><p>###xhr对象的readyState属性</p><table><thead><tr><th>值</th><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>UNSENT</td><td>XMLHttpRequest对象已被创建，但尚未调用open方法。</td></tr><tr><td>1</td><td>OPENED</td><td>open方法已被调用</td></tr><tr><td>2</td><td>HEADERS_RECEIVED</td><td>send方法已被调用，响应头已被接收</td></tr><tr><td>3</td><td>LOADING</td><td>数据接收中，此时response属性中已包含部分数据</td></tr><tr><td>4</td><td>DONE</td><td>ajax请求完成，意味着数据传输已经彻底完成（或失败）</td></tr></tbody></table><h3 id="xhr发起GET请求"><a href="#xhr发起GET请求" class="headerlink" title="xhr发起GET请求"></a>xhr发起GET请求</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 1. 创建 XHR 对象</span>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()    <span class="hljs-comment">// 2. 调用 open 函数</span>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks?id=1&#x27;</span>)<span class="hljs-comment">//?后接查询字符串</span>    <span class="hljs-comment">// 3. 调用 send 函数</span>    xhr.<span class="hljs-title function_">send</span>()    <span class="hljs-comment">// 4. 监听 onreadystatechange 事件 固定写法</span>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;        <span class="hljs-comment">// 获取服务器响应的数据</span>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)      &#125;&#125;</code></pre><ul><li><p>查询字符串：在URL的末尾加上用于向服务器发送信息的变量，多个变量之间用&amp;隔开</p></li><li><p>URL编码：url中不允许有中文，会转换成%E8%A5这样的形式。可以用encodeURI(‘中文’)来转换，和decodeURI（’URL编码）解码。大多数情况浏览器都是自动转换的。</p></li></ul><p>###xhr发起POST请求</p><pre><code class="hljs javascript"><span class="hljs-comment">//以下步骤必须按顺序写，否则会出错。</span><span class="hljs-comment">// 1. 创建 xhr 对象</span>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()    <span class="hljs-comment">// 2. 调用 open 函数</span>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>)    <span class="hljs-comment">// 3. 设置 Content-Type 属性，固定写法</span>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)    <span class="hljs-comment">// 4. 调用 send 函数</span>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;bookname=水浒传&amp;author=施耐庵&amp;publisher=上海图书出版社&#x27;</span>)    <span class="hljs-comment">// 5. 监听事件</span>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)      &#125;&#125;</code></pre><h3 id="xhr超时"><a href="#xhr超时" class="headerlink" title="xhr超时"></a>xhr超时</h3><pre><code class="hljs javascript"><span class="hljs-comment">// 设置 超时时间</span>    xhr.<span class="hljs-property">timeout</span> = <span class="hljs-number">30</span>    <span class="hljs-comment">// 设置超时以后的处理函数</span>    xhr.<span class="hljs-property">ontimeout</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求超时了！&#x27;</span>)    &#125;</code></pre><h3 id="xhr表单操作"><a href="#xhr表单操作" class="headerlink" title="xhr表单操作"></a>xhr表单操作</h3><pre><code class="hljs javascript"><span class="hljs-number">1.</span><span class="hljs-title class_">FormData</span>对象的使用<span class="hljs-comment">// 创建 FormData 实例</span>    <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()    <span class="hljs-comment">// 调用 append 函数，向 fd 中追加数据</span>    fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;uname&#x27;</span>, <span class="hljs-string">&#x27;zs&#x27;</span>)    fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;upwd&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)<span class="hljs-number">2.</span><span class="hljs-title class_">FormData</span>对象管理表单数据<span class="hljs-comment">// 1. 通过 DOM 操作，获取到 form 表单元素</span>    <span class="hljs-keyword">var</span> form = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#form1&#x27;</span>)    form.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;      <span class="hljs-comment">// 阻止表单的默认提交行为</span>      e.<span class="hljs-title function_">preventDefault</span>()      <span class="hljs-comment">// 创建 FormData，快速获取到 form 表单中的数据</span>      <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>(form)      <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()      xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/formdata&#x27;</span>)      xhr.<span class="hljs-title function_">send</span>(fd)      xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>))&#125;&#125;&#125;)</code></pre><h3 id="xhr文件上传"><a href="#xhr文件上传" class="headerlink" title="xhr文件上传"></a>xhr文件上传</h3><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 1. 文件选择框 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file1&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 2. 上传文件的按钮 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnUpload&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <span class="hljs-comment">&lt;!-- bootstrap 中的进度条 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;progress&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 500px; margin: 15px 10px;&quot;</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;progress-bar progress-bar-striped active&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 0%&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;percent&quot;</span>&gt;</span>0%<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 3. img 标签，来显示上传成功以后的图片 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">   <span class="hljs-comment">// 1. 获取到文件上传按钮</span></span><span class="language-javascript">   <span class="hljs-keyword">var</span> btnUpload = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btnUpload&#x27;</span>)</span><span class="language-javascript">   <span class="hljs-comment">// 2. 为按钮绑定单击事件处理函数</span></span><span class="language-javascript">   btnUpload.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">     <span class="hljs-comment">// 3. 获取到用户选择的文件列表</span></span><span class="language-javascript">     <span class="hljs-keyword">var</span> files = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#file1&#x27;</span>).<span class="hljs-property">files</span></span><span class="language-javascript">     <span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">       <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择要上传的文件！&#x27;</span>)</span><span class="language-javascript">     &#125;</span><span class="language-javascript">     <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><span class="language-javascript">     <span class="hljs-comment">// 将用户选择的文件，添加到 FormData 中</span></span><span class="language-javascript">     fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])</span><span class="language-javascript"></span><span class="language-javascript">     <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()</span><span class="language-javascript"></span><span class="language-javascript">     <span class="hljs-comment">// 监听文件上传的进度</span></span><span class="language-javascript">     xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">       <span class="hljs-keyword">if</span> (e.<span class="hljs-property">lengthComputable</span>) &#123;</span><span class="language-javascript">         <span class="hljs-comment">// 计算出上传的进度 celi对小数向上取整</span></span><span class="language-javascript">         <span class="hljs-keyword">var</span> procentComplete = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>((e.<span class="hljs-property">loaded</span> / e.<span class="hljs-property">total</span>) * <span class="hljs-number">100</span>)</span><span class="language-javascript">         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(procentComplete)</span><span class="language-javascript">         <span class="hljs-comment">// 动态设置百分比进度条</span></span><span class="language-javascript">         $(<span class="hljs-string">&#x27;#percent&#x27;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;width: &#x27;</span> + procentComplete + <span class="hljs-string">&#x27;%;&#x27;</span>).<span class="hljs-title function_">html</span>(procentComplete + <span class="hljs-string">&#x27;%&#x27;</span>)&#125;&#125;</span><span class="language-javascript"></span><span class="language-javascript">     xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">       $(<span class="hljs-string">&#x27;#percent&#x27;</span>).<span class="hljs-title function_">removeClass</span>().<span class="hljs-title function_">addClass</span>(<span class="hljs-string">&#x27;progress-bar progress-bar-success&#x27;</span>)&#125;</span><span class="language-javascript"></span><span class="language-javascript">     xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>)</span><span class="language-javascript">     xhr.<span class="hljs-title function_">send</span>(fd)</span><span class="language-javascript"></span><span class="language-javascript">     xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">       <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;</span><span class="language-javascript">         <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)</span><span class="language-javascript">         <span class="hljs-keyword">if</span> (data.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;</span><span class="language-javascript">           <span class="hljs-comment">// 上传成功</span></span><span class="language-javascript">           <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#img&#x27;</span>).<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006&#x27;</span> + data.<span class="hljs-property">url</span></span><span class="language-javascript">         &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="language-javascript">           <span class="hljs-comment">// 上传失败</span></span><span class="language-javascript">           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;图片上传失败！&#x27;</span> + data.<span class="hljs-property">message</span>)&#125;&#125;&#125;&#125;)</span><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xhrHttp的基本使用&quot;&gt;&lt;a href=&quot;#xhrHttp的基本使用&quot; class=&quot;headerlink&quot; title=&quot;xhrHttp的基本使用&quot;&gt;&lt;/a&gt;xhrHttp的基本使用&lt;/h1&gt;&lt;p&gt;xhr是最基础的数据交互方法，通常不会去使用，了解即可。&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ajax以及axios发送请求及文件上传</title>
    <link href="http://example.com/2023/04/05/ajax%E4%BB%A5%E5%8F%8Aaxios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2023/04/05/ajax%E4%BB%A5%E5%8F%8Aaxios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</id>
    <published>2023-04-05T03:15:13.776Z</published>
    <updated>2023-04-12T02:58:24.054Z</updated>
    
    <content type="html"><![CDATA[<p>##Jquery发送请求</p><p>浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。jQuery 中发起 Ajax 请求最常用的三个方法如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">//1.get请求</span><span class="hljs-comment">//入口函数</span>$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">//点击事件</span>      $(<span class="hljs-string">&#x27;#btnGETINFO&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-comment">//请求体 $.get(url, [data], [callback])</span>        $.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>, &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span> &#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;)&#125;)&#125;)<span class="hljs-comment">//2.post请求</span>$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      $(<span class="hljs-string">&#x27;#btnPOST&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;          <span class="hljs-comment">//$.post(url,[data],[callback])</span>        $.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/addbook&#x27;</span>, &#123; <span class="hljs-attr">bookname</span>: <span class="hljs-string">&#x27;水浒传&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;施耐庵&#x27;</span>, <span class="hljs-attr">publisher</span>: <span class="hljs-string">&#x27;天津图书出版社&#x27;</span>&#125;, <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;)&#125;)&#125;)<span class="hljs-comment">//3.ajax请求</span>$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;      $(<span class="hljs-string">&#x27;#btnGET&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        $.<span class="hljs-title function_">ajax</span>(&#123;          <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<span class="hljs-comment">//请求方式</span>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>,<span class="hljs-comment">//URL地址</span>          <span class="hljs-attr">data</span>: &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;,<span class="hljs-comment">//请求要携带的数据</span>          <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;&#125;)&#125;)&#125;)<span class="hljs-comment">//回调函数</span></code></pre><p>###封装一个在自己的ajax函数</p><pre><code class="hljs javascript"><span class="hljs-comment">// 处理data参数，转化成查询字符串的形式，从而提交给服务器。</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveData</span>(<span class="hljs-params">data</span>) &#123;  <span class="hljs-keyword">var</span> arr = []<span class="hljs-comment">//  &#123;key+&#x27;=&#x27;+value&#125; =&gt; &#123;name=zs&amp;age=20&#125;</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> data) &#123;    <span class="hljs-keyword">var</span> str = k + <span class="hljs-string">&#x27;=&#x27;</span> + data[k]    arr.<span class="hljs-title function_">push</span>(str)&#125;  <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#125;<span class="hljs-comment">// Ajax函数主体</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">itheima</span>(<span class="hljs-params">options</span>) &#123;<span class="hljs-comment">// 新建xhr对象</span>  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()  <span class="hljs-comment">// 把外界传递过来的参数对象，转换为 查询字符串</span>  <span class="hljs-keyword">var</span> qs = <span class="hljs-title function_">resolveData</span>(options.<span class="hljs-property">data</span>)  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">method</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;GET&#x27;</span>) &#123;    <span class="hljs-comment">// 发起GET请求</span>    xhr.<span class="hljs-title function_">open</span>(options.<span class="hljs-property">method</span>, options.<span class="hljs-property">url</span> + <span class="hljs-string">&#x27;?&#x27;</span> + qs)    xhr.<span class="hljs-title function_">send</span>()  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (options.<span class="hljs-property">method</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;    <span class="hljs-comment">// 发起POST请求</span>    xhr.<span class="hljs-title function_">open</span>(options.<span class="hljs-property">method</span>, options.<span class="hljs-property">url</span>)    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/x-www-form-urlencoded&#x27;</span>)    xhr.<span class="hljs-title function_">send</span>(qs)&#125;     <span class="hljs-comment">// 监听请求成功的状态</span>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;    <span class="hljs-keyword">var</span> result = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)    options.<span class="hljs-title function_">success</span>(result)&#125;&#125;&#125;</code></pre><h3 id="Jquery文件上传"><a href="#Jquery文件上传" class="headerlink" title="Jquery文件上传"></a>Jquery文件上传</h3><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file1&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btnUpload&quot;</span>&gt;</span>上传文件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-comment">&lt;!--loading动画 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./images/loading.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;loading&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        <span class="hljs-comment">// 监听到Ajax请求被发起了 loading动画显示</span></span><span class="language-javascript">        $(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ajaxStart</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          $(<span class="hljs-string">&#x27;#loading&#x27;</span>).<span class="hljs-title function_">show</span>()&#125;)</span><span class="language-javascript"></span><span class="language-javascript">        <span class="hljs-comment">// 监听到 Ajax 完成的事件</span></span><span class="language-javascript">        $(<span class="hljs-variable language_">document</span>).<span class="hljs-title function_">ajaxStop</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          $(<span class="hljs-string">&#x27;#loading&#x27;</span>).<span class="hljs-title function_">hide</span>()&#125;)</span><span class="language-javascript"><span class="hljs-comment">//绑定点击事件</span></span><span class="language-javascript">        $(<span class="hljs-string">&#x27;#btnUpload&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-keyword">var</span> files = $(<span class="hljs-string">&#x27;#file1&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">files</span></span><span class="language-javascript">          <span class="hljs-keyword">if</span> (files.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">0</span>) &#123;</span><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择文件后再上传！&#x27;</span>)&#125;</span><span class="language-javascript"><span class="hljs-comment">//创建FormData对象</span></span><span class="language-javascript">          <span class="hljs-keyword">var</span> fd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>()</span><span class="language-javascript">          fd.<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;avatar&#x27;</span>, files[<span class="hljs-number">0</span>])</span><span class="language-javascript">          <span class="hljs-comment">// 发起 jQuery 的 Ajax 请求，上传文件</span></span><span class="language-javascript">          $.<span class="hljs-title function_">ajax</span>(&#123;</span><span class="language-javascript">            <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,</span><span class="language-javascript">            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/upload/avatar&#x27;</span>,</span><span class="language-javascript">            <span class="hljs-attr">data</span>: fd,</span><span class="language-javascript">            <span class="hljs-comment">// 表示不对formdata的数据进行url编码，原样发送、</span></span><span class="language-javascript">            <span class="hljs-attr">processData</span>: <span class="hljs-literal">false</span>,</span><span class="language-javascript">            <span class="hljs-comment">//表示使用默认值不修改type</span></span><span class="language-javascript">            <span class="hljs-attr">contentType</span>: <span class="hljs-literal">false</span>,</span><span class="language-javascript">            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;</span><span class="language-javascript">              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)&#125;&#125;)&#125;)&#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h3 id="axios发送请求"><a href="#axios发送请求" class="headerlink" title="axios发送请求"></a>axios发送请求</h3><p>axios是专注于网络请求的库，相比jquery更加方便.会返回一个res对象，其中res.data才是服务器返回的数据。</p><pre><code class="hljs javascript"><span class="hljs-comment">// GET请求 axios.get(url, &#123; params: &#123;参数&#125; &#125;).then(callback) </span><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/get&#x27;</span>    <span class="hljs-keyword">var</span> paramsObj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;    axios.<span class="hljs-title function_">get</span>(url, &#123; <span class="hljs-attr">params</span>: paramsObj &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)&#125;)<span class="hljs-comment">// POST请求 axios.get(url,&#123;参数&#125;).then(callback)注意参数区别</span><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>    <span class="hljs-keyword">var</span> dataObj = &#123; <span class="hljs-attr">address</span>: <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-attr">location</span>: <span class="hljs-string">&#x27;顺义区&#x27;</span> &#125;    axios.<span class="hljs-title function_">post</span>(url, dataObj).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)&#125;)<span class="hljs-comment">//也可以用类ajax格式</span><span class="hljs-title function_">axios</span>(&#123;        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;请求类型&#x27;</span>,        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;url地址&#x27;</span>,        <span class="hljs-attr">data</span>:&#123;post数据&#125;,        <span class="hljs-attr">params</span>: &#123;<span class="hljs-variable constant_">GET</span>参数&#125;      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>)&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##Jquery发送请求&lt;/p&gt;
&lt;p&gt;浏览器中提供的 XMLHttpRequest 用法比较复杂，所以 jQuery 对 XMLHttpRequest 进行了封装，提供了一系列 Ajax 相关的函数，极大地降低了 Ajax 的使用难度。jQuery 中发起 Ajax 请求</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>处理this与节流防抖</title>
    <link href="http://example.com/2023/04/05/this%E4%B8%8E%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>http://example.com/2023/04/05/this%E4%B8%8E%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</id>
    <published>2023-04-05T01:28:37.879Z</published>
    <updated>2023-05-06T01:39:52.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理this"><a href="#处理this" class="headerlink" title="处理this"></a>处理this</h2><p><code>this</code> 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 <code>this</code> 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 <code>this</code> 默认的取值】情况进行归纳和总结。</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p><strong>普通函数</strong>的调用方式决定了 <code>this</code> 的值，即【谁调用 <code>this</code> 的值指向谁】，如下代码所示：</p><pre><code class="hljs javascript">  <span class="hljs-comment">// 普通函数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;  <span class="hljs-comment">// 函数表达式</span>  <span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;  <span class="hljs-comment">// 函数的调用方式决定了 this 的值</span>  <span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// window</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayHi</span>()<span class="hljs-comment">// 普通对象</span>  <span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,    <span class="hljs-attr">walk</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;&#125;  <span class="hljs-comment">// 动态为 user 添加方法</span>  user.<span class="hljs-property">sayHi</span> = sayHi  uesr.<span class="hljs-property">sayHello</span> = sayHello  <span class="hljs-comment">// 函数调用方式，决定了 this 的值</span>  user.<span class="hljs-title function_">sayHi</span>()  user.<span class="hljs-title function_">sayHello</span>()</code></pre><p>注： 普通函数没有明确调用者时 <code>this</code> 值为 <code>window</code>，严格模式下没有调用者时 <code>this</code> 的值为 <code>undefined</code>。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数</strong>中的 <code>this</code> 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 <code>this</code> ！箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 此处为 window</span><span class="hljs-comment">// 箭头函数</span><span class="hljs-keyword">const</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this </span><span class="hljs-comment">// 普通对象</span><span class="hljs-keyword">const</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this 一致</span>  <span class="hljs-attr">walk</span>: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;,  <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 与 sleep 中的 this 一致</span>    <span class="hljs-comment">// 调用箭头函数</span>    <span class="hljs-title function_">fn</span>();&#125;&#125;<span class="hljs-comment">// 动态添加方法</span>user.<span class="hljs-property">sayHi</span> = sayHi<span class="hljs-comment">// 函数调用</span>user.<span class="hljs-title function_">sayHi</span>()</code></pre><p>在开发中【使用箭头函数前需要考虑函数中 <code>this</code> 的值】，<strong>事件回调函数</strong>使用箭头函数时，<code>this</code> 为全局的 <code>window</code>，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>)<span class="hljs-comment">// 箭头函数 此时 this 指向了 window</span>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)<span class="hljs-comment">// 普通函数 此时 this 指向了 DOM 对象</span>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)</code></pre><p>同样由于箭头函数 <code>this</code> 的原因，<strong>基于原型的面向对象也不推荐采用箭头函数</strong>，如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">// 原型对像上添加了箭头函数</span><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">walk</span> = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125; <span class="hljs-comment">// window</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()p1.<span class="hljs-title function_">walk</span>()</code></pre><h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p>以上归纳了普通函数和箭头函数中关于 <code>this</code> 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 <code>this</code> 的指向，有 3 个方法可以动态指定普通函数中 <code>this</code> 的指向：</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<span class="hljs-keyword">let</span> student = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;<span class="hljs-comment">// 调用函数并指定 this 的值</span>sayHi.<span class="hljs-title function_">call</span>(user); <span class="hljs-comment">// this 值为 user</span>sayHi.<span class="hljs-title function_">call</span>(student); <span class="hljs-comment">// this 值为 student</span><span class="hljs-comment">// 求和函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-comment">// 调用 counter 函数，并传入参数</span><span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre><p>总结：</p><ol><li><code>call</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li><li>使用 <code>call</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li><li><code>call</code> 方法的其余参数会依次自动传入函数做为函数的参数</li></ol><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;<span class="hljs-keyword">let</span> student = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;<span class="hljs-comment">// 调用函数并指定 this 的值</span>sayHi.<span class="hljs-title function_">apply</span>(user) <span class="hljs-comment">// this 值为 user</span>sayHi.<span class="hljs-title function_">apply</span>(student) <span class="hljs-comment">// this 值为 student</span><span class="hljs-comment">// 求和函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;  <span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-comment">// 调用 counter 函数，并传入参数</span><span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>])</code></pre><p>总结：</p><ol><li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li><li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li><li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li></ol><h4 id="bind（重点）"><a href="#bind（重点）" class="headerlink" title="bind（重点）"></a>bind（重点）</h4><p><code>bind</code> 方法并<strong>不会调用函数</strong>，而是创建一个指定了 <code>this</code> 值的新函数，使用方法如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<span class="hljs-comment">// 调用 bind 指定 this 的值</span><span class="hljs-keyword">let</span> sayHello = sayHi.<span class="hljs-title function_">bind</span>(user);<span class="hljs-comment">// 调用使用 bind 创建的新函数</span><span class="hljs-title function_">sayHello</span>()</code></pre><p>注：<code>bind</code> 方法创建新的函数，与原函数的唯一的变化是改变了 <code>this</code> 的值。</p><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><ol><li>防抖（debounce）<br>  所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</li></ol><p>  应用场景：输入框连续输入，结束时才去查询。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125; <span class="hljs-comment">// 如果里面存在大量操作 dom 的情况，会卡顿</span>    <span class="hljs-comment">// 防抖函数</span>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, t</span>) &#123;      <span class="hljs-keyword">let</span> timeId      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 如果有定时器就清除</span>        <span class="hljs-keyword">if</span> (timeId) <span class="hljs-built_in">clearTimeout</span>(timeId)        <span class="hljs-comment">// 开启定时器 200</span>        timeId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()&#125;, t)&#125;&#125;    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">debounce</span>(mouseMove, <span class="hljs-number">200</span>))</code></pre><ol start="2"><li>节流（throttle）<br>  所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数</li></ol><p>  应用场景：鼠标连续点击、拖动等。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)   <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125;   <span class="hljs-comment">// 节流函数</span>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, t</span>) &#123;     <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;       <span class="hljs-comment">//如果没有定时器就创建定时器</span>       <span class="hljs-keyword">if</span> (!timer) &#123;         timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()           timer = <span class="hljs-literal">null</span> &#125;, t)&#125;&#125;&#125;   box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">throttle</span>(mouseMove, <span class="hljs-number">2000</span>))</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;处理this&quot;&gt;&lt;a href=&quot;#处理this&quot; class=&quot;headerlink&quot; title=&quot;处理this&quot;&gt;&lt;/a&gt;处理this&lt;/h2&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 &lt;cod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>拷贝与异常捕获</title>
    <link href="http://example.com/2023/04/03/%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <id>http://example.com/2023/04/03/%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</id>
    <published>2023-04-03T07:06:29.438Z</published>
    <updated>2023-04-12T03:00:07.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>首先浅拷贝和深拷贝只针对引用类型</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝：拷贝的是地址</p><p>常见方法：</p><ol><li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li><li>拷贝数组：Array.prototype.concat() 或者 […arr]</li></ol><blockquote><p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 。</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝：拷贝的是对象，不是地址</p><p>常见方法：</p><ol><li>通过递归实现深拷贝</li><li>lodash&#x2F;cloneDeep</li><li>通过JSON.stringify()实现</li></ol><h4 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h4><p>函数递归：由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],  <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;<span class="hljs-keyword">const</span> o = &#123;&#125;<span class="hljs-comment">// 拷贝函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">newObj, oldObj</span>) &#123;  <span class="hljs-keyword">debugger</span><span class="hljs-comment">//相当于断点调试</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldObj) &#123;    <span class="hljs-comment">// 处理数组的问题  一定先写数组 在写 对象 不能颠倒</span>    <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;      newObj[k] = []      <span class="hljs-comment">//  newObj[k] 接收 []  hobby</span>      <span class="hljs-comment">//  oldObj[k]   [&#x27;乒乓球&#x27;, &#x27;足球&#x27;]</span>      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;      newObj[k] = &#123;&#125;      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])&#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//  k  属性名 uname age    oldObj[k]  属性值  18</span>      <span class="hljs-comment">// newObj[k]  === o.uname  给新对象添加属性</span>      newObj[k] = oldObj[k]&#125;&#125;&#125;<span class="hljs-title function_">deepCopy</span>(o, obj) <span class="hljs-comment">// 函数调用  两个参数 o 新对象  obj 旧对象</span>o.<span class="hljs-property">hobby</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;篮球&#x27;</span>o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">23</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</code></pre><h4 id="js库lodash里面cloneDeep内部实现了深拷贝"><a href="#js库lodash里面cloneDeep内部实现了深拷贝" class="headerlink" title="js库lodash里面cloneDeep内部实现了深拷贝"></a>js库lodash里面cloneDeep内部实现了深拷贝</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">   <span class="hljs-keyword">const</span> obj = &#123;</span><span class="language-javascript">     <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,</span><span class="language-javascript">     <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],</span><span class="language-javascript">     <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;</span><span class="language-javascript">   <span class="hljs-keyword">const</span> o = _.<span class="hljs-title function_">cloneDeep</span>(obj)</span><span class="language-javascript">   o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span></span><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 把对象转换为 JSON 字符串</span><span class="hljs-keyword">const</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;   <span class="hljs-keyword">if</span>(!x || !y) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数不能为空!&#x27;</span>)&#125;<span class="hljs-comment">// throw &#x27;参数不能为空!&#x27;;</span>   <span class="hljs-keyword">return</span> x + y&#125; <span class="hljs-title function_">counter</span>()</code></pre><p>总结：</p><ol><li><code>throw</code> 抛出异常信息，程序也会终止执行</li><li><code>throw</code> 后面跟的是错误提示信息</li><li><code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息</li></ol><h3 id="try-…-catch"><a href="#try-…-catch" class="headerlink" title="try … catch"></a>try … catch</h3><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">try</span> &#123;     <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.p&#x27;</span>)     p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>&#125;     <span class="hljs-keyword">catch</span> (error) &#123;     <span class="hljs-comment">// try 代码段中执行有错误时，会执行 catch 代码段</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)     <span class="hljs-comment">// 终止代码继续执行</span>     <span class="hljs-keyword">return</span>&#125;   <span class="hljs-keyword">finally</span> &#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;执行&#x27;</span>)&#125;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;如果出现错误，我的语句不会执行&#x27;</span>)&#125; <span class="hljs-title function_">foo</span>()</code></pre><p>总结：</p><ol><li><code>try...catch</code> 用于捕获错误信息</li><li>将预估可能发生错误的代码写在 <code>try</code> 代码段中</li><li>如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h2&gt;&lt;p&gt;首先浅拷贝和深拷贝只针对引用类型&lt;/p&gt;
&lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
</feed>
