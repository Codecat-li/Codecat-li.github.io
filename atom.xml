<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子安的前端世界</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-05T01:29:18.070Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>李宝霖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/05/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>http://example.com/2023/04/05/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</id>
    <published>2023-04-05T01:29:18.070Z</published>
    <updated>2023-04-05T01:29:18.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-进阶-第4天"><a href="#JavaScript-进阶-第4天" class="headerlink" title="JavaScript 进阶 - 第4天"></a>JavaScript 进阶 - 第4天</h1><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>首先浅拷贝和深拷贝只针对引用类型</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝：拷贝的是地址</p><p>常见方法：</p><ol><li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li><li>拷贝数组：Array.prototype.concat() 或者 […arr]</li></ol><blockquote><p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 。</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝：拷贝的是对象，不是地址</p><p>常见方法：</p><ol><li>通过递归实现深拷贝</li><li>lodash&#x2F;cloneDeep</li><li>通过JSON.stringify()实现</li></ol><h4 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h4><p>函数递归：由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],  <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;<span class="hljs-keyword">const</span> o = &#123;&#125;<span class="hljs-comment">// 拷贝函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">newObj, oldObj</span>) &#123;  <span class="hljs-keyword">debugger</span><span class="hljs-comment">//相当于断点调试</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldObj) &#123;    <span class="hljs-comment">// 处理数组的问题  一定先写数组 在写 对象 不能颠倒</span>    <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;      newObj[k] = []      <span class="hljs-comment">//  newObj[k] 接收 []  hobby</span>      <span class="hljs-comment">//  oldObj[k]   [&#x27;乒乓球&#x27;, &#x27;足球&#x27;]</span>      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;      newObj[k] = &#123;&#125;      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])&#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//  k  属性名 uname age    oldObj[k]  属性值  18</span>      <span class="hljs-comment">// newObj[k]  === o.uname  给新对象添加属性</span>      newObj[k] = oldObj[k]&#125;&#125;&#125;<span class="hljs-title function_">deepCopy</span>(o, obj) <span class="hljs-comment">// 函数调用  两个参数 o 新对象  obj 旧对象</span>o.<span class="hljs-property">hobby</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;篮球&#x27;</span>o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">23</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</code></pre><h4 id="js库lodash里面cloneDeep内部实现了深拷贝"><a href="#js库lodash里面cloneDeep内部实现了深拷贝" class="headerlink" title="js库lodash里面cloneDeep内部实现了深拷贝"></a>js库lodash里面cloneDeep内部实现了深拷贝</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">   <span class="hljs-keyword">const</span> obj = &#123;</span><span class="language-javascript">     <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,</span><span class="language-javascript">     <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],</span><span class="language-javascript">     <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;</span><span class="language-javascript">   <span class="hljs-keyword">const</span> o = _.<span class="hljs-title function_">cloneDeep</span>(obj)</span><span class="language-javascript">   o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span></span><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 把对象转换为 JSON 字符串</span><span class="hljs-keyword">const</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;   <span class="hljs-keyword">if</span>(!x || !y) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数不能为空!&#x27;</span>)&#125;<span class="hljs-comment">// throw &#x27;参数不能为空!&#x27;;</span>   <span class="hljs-keyword">return</span> x + y&#125; <span class="hljs-title function_">counter</span>()</code></pre><p>总结：</p><ol><li><code>throw</code> 抛出异常信息，程序也会终止执行</li><li><code>throw</code> 后面跟的是错误提示信息</li><li><code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息</li></ol><h3 id="try-…-catch"><a href="#try-…-catch" class="headerlink" title="try … catch"></a>try … catch</h3><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">try</span> &#123;     <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.p&#x27;</span>)     p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>&#125;     <span class="hljs-keyword">catch</span> (error) &#123;     <span class="hljs-comment">// try 代码段中执行有错误时，会执行 catch 代码段</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)     <span class="hljs-comment">// 终止代码继续执行</span>     <span class="hljs-keyword">return</span>&#125;   <span class="hljs-keyword">finally</span> &#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;执行&#x27;</span>)&#125;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;如果出现错误，我的语句不会执行&#x27;</span>)&#125; <span class="hljs-title function_">foo</span>()</code></pre><p>总结：</p><ol><li><code>try...catch</code> 用于捕获错误信息</li><li>将预估可能发生错误的代码写在 <code>try</code> 代码段中</li><li>如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li></ol><h2 id="处理this"><a href="#处理this" class="headerlink" title="处理this"></a>处理this</h2><p><code>this</code> 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 <code>this</code> 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 <code>this</code> 默认的取值】情况进行归纳和总结。</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p><strong>普通函数</strong>的调用方式决定了 <code>this</code> 的值，即【谁调用 <code>this</code> 的值指向谁】，如下代码所示：</p><pre><code class="hljs javascript">  <span class="hljs-comment">// 普通函数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;  <span class="hljs-comment">// 函数表达式</span>  <span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;  <span class="hljs-comment">// 函数的调用方式决定了 this 的值</span>  <span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// window</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayHi</span>()<span class="hljs-comment">// 普通对象</span>  <span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,    <span class="hljs-attr">walk</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;&#125;  <span class="hljs-comment">// 动态为 user 添加方法</span>  user.<span class="hljs-property">sayHi</span> = sayHi  uesr.<span class="hljs-property">sayHello</span> = sayHello  <span class="hljs-comment">// 函数调用方式，决定了 this 的值</span>  user.<span class="hljs-title function_">sayHi</span>()  user.<span class="hljs-title function_">sayHello</span>()</code></pre><p>注： 普通函数没有明确调用者时 <code>this</code> 值为 <code>window</code>，严格模式下没有调用者时 <code>this</code> 的值为 <code>undefined</code>。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数</strong>中的 <code>this</code> 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 <code>this</code> ！箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 此处为 window</span><span class="hljs-comment">// 箭头函数</span><span class="hljs-keyword">const</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this </span><span class="hljs-comment">// 普通对象</span><span class="hljs-keyword">const</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this 一致</span>  <span class="hljs-attr">walk</span>: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;,  <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 与 sleep 中的 this 一致</span>    <span class="hljs-comment">// 调用箭头函数</span>    <span class="hljs-title function_">fn</span>();&#125;&#125;<span class="hljs-comment">// 动态添加方法</span>user.<span class="hljs-property">sayHi</span> = sayHi<span class="hljs-comment">// 函数调用</span>user.<span class="hljs-title function_">sayHi</span>()</code></pre><p>在开发中【使用箭头函数前需要考虑函数中 <code>this</code> 的值】，<strong>事件回调函数</strong>使用箭头函数时，<code>this</code> 为全局的 <code>window</code>，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>)<span class="hljs-comment">// 箭头函数 此时 this 指向了 window</span>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)<span class="hljs-comment">// 普通函数 此时 this 指向了 DOM 对象</span>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)</code></pre><p>同样由于箭头函数 <code>this</code> 的原因，<strong>基于原型的面向对象也不推荐采用箭头函数</strong>，如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">// 原型对像上添加了箭头函数</span><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">walk</span> = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125; <span class="hljs-comment">// window</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()p1.<span class="hljs-title function_">walk</span>()</code></pre><h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p>以上归纳了普通函数和箭头函数中关于 <code>this</code> 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 <code>this</code> 的指向，有 3 个方法可以动态指定普通函数中 <code>this</code> 的指向：</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<span class="hljs-keyword">let</span> student = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;<span class="hljs-comment">// 调用函数并指定 this 的值</span>sayHi.<span class="hljs-title function_">call</span>(user); <span class="hljs-comment">// this 值为 user</span>sayHi.<span class="hljs-title function_">call</span>(student); <span class="hljs-comment">// this 值为 student</span><span class="hljs-comment">// 求和函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-comment">// 调用 counter 函数，并传入参数</span><span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre><p>总结：</p><ol><li><code>call</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li><li>使用 <code>call</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li><li><code>call</code> 方法的其余参数会依次自动传入函数做为函数的参数</li></ol><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;<span class="hljs-keyword">let</span> student = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;<span class="hljs-comment">// 调用函数并指定 this 的值</span>sayHi.<span class="hljs-title function_">apply</span>(user) <span class="hljs-comment">// this 值为 user</span>sayHi.<span class="hljs-title function_">apply</span>(student) <span class="hljs-comment">// this 值为 student</span><span class="hljs-comment">// 求和函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;  <span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-comment">// 调用 counter 函数，并传入参数</span><span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>])</code></pre><p>总结：</p><ol><li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li><li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li><li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li></ol><h4 id="bind（重点）"><a href="#bind（重点）" class="headerlink" title="bind（重点）"></a>bind（重点）</h4><p><code>bind</code> 方法并<strong>不会调用函数</strong>，而是创建一个指定了 <code>this</code> 值的新函数，使用方法如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<span class="hljs-comment">// 调用 bind 指定 this 的值</span><span class="hljs-keyword">let</span> sayHello = sayHi.<span class="hljs-title function_">bind</span>(user);<span class="hljs-comment">// 调用使用 bind 创建的新函数</span><span class="hljs-title function_">sayHello</span>()</code></pre><p>注：<code>bind</code> 方法创建新的函数，与原函数的唯一的变化是改变了 <code>this</code> 的值。</p><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><ol><li>防抖（debounce）<br>  所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125; <span class="hljs-comment">// 如果里面存在大量操作 dom 的情况，会卡顿</span>    <span class="hljs-comment">// 防抖函数</span>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, t</span>) &#123;      <span class="hljs-keyword">let</span> timeId      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 如果有定时器就清除</span>        <span class="hljs-keyword">if</span> (timeId) <span class="hljs-built_in">clearTimeout</span>(timeId)        <span class="hljs-comment">// 开启定时器 200</span>        timeId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()&#125;, t)&#125;&#125;    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">debounce</span>(mouseMove, <span class="hljs-number">200</span>))</code></pre><ol start="2"><li>节流（throttle）<br>  所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)   <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125;   <span class="hljs-comment">// 节流函数</span>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, t</span>) &#123;     <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;       <span class="hljs-comment">//如果没有定时器就创建定时器</span>       <span class="hljs-keyword">if</span> (!timer) &#123;         timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()           timer = <span class="hljs-literal">null</span> &#125;, t)&#125;&#125;&#125;   box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">throttle</span>(mouseMove, <span class="hljs-number">2000</span>))</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-进阶-第4天&quot;&gt;&lt;a href=&quot;#JavaScript-进阶-第4天&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 进阶 - 第4天&quot;&gt;&lt;/a&gt;JavaScript 进阶 - 第4天&lt;/h1&gt;&lt;h2 id=&quot;深</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/05/this%E4%B8%8E%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"/>
    <id>http://example.com/2023/04/05/this%E4%B8%8E%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/</id>
    <published>2023-04-05T01:28:37.879Z</published>
    <updated>2023-04-05T01:31:06.710Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-处理this与节流防抖"><a href="#title-处理this与节流防抖" class="headerlink" title="title:处理this与节流防抖"></a>title:处理this与节流防抖</h2><h2 id="处理this"><a href="#处理this" class="headerlink" title="处理this"></a>处理this</h2><p><code>this</code> 是 JavaScript 最具“魅惑”的知识点，不同的应用场合 <code>this</code> 的取值可能会有意想不到的结果，在此我们对以往学习过的关于【 <code>this</code> 默认的取值】情况进行归纳和总结。</p><h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p><strong>普通函数</strong>的调用方式决定了 <code>this</code> 的值，即【谁调用 <code>this</code> 的值指向谁】，如下代码所示：</p><pre><code class="hljs javascript">  <span class="hljs-comment">// 普通函数</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;  <span class="hljs-comment">// 函数表达式</span>  <span class="hljs-keyword">const</span> sayHello = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;  <span class="hljs-comment">// 函数的调用方式决定了 this 的值</span>  <span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// window</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayHi</span>()<span class="hljs-comment">// 普通对象</span>  <span class="hljs-keyword">const</span> user = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,    <span class="hljs-attr">walk</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;&#125;  <span class="hljs-comment">// 动态为 user 添加方法</span>  user.<span class="hljs-property">sayHi</span> = sayHi  uesr.<span class="hljs-property">sayHello</span> = sayHello  <span class="hljs-comment">// 函数调用方式，决定了 this 的值</span>  user.<span class="hljs-title function_">sayHi</span>()  user.<span class="hljs-title function_">sayHello</span>()</code></pre><p>注： 普通函数没有明确调用者时 <code>this</code> 值为 <code>window</code>，严格模式下没有调用者时 <code>this</code> 的值为 <code>undefined</code>。</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p><strong>箭头函数</strong>中的 <code>this</code> 与普通函数完全不同，也不受调用方式的影响，事实上箭头函数中并不存在 <code>this</code> ！箭头函数中访问的 <code>this</code> 不过是箭头函数所在作用域的 <code>this</code> 变量。</p><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// 此处为 window</span><span class="hljs-comment">// 箭头函数</span><span class="hljs-keyword">const</span> sayHi = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this </span><span class="hljs-comment">// 普通对象</span><span class="hljs-keyword">const</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-comment">// 该箭头函数中的 this 为函数声明环境中 this 一致</span>  <span class="hljs-attr">walk</span>: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;,  <span class="hljs-attr">sleep</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;    <span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;hello&#x27;</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)    <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; &#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125; <span class="hljs-comment">// 该箭头函数中的 this 与 sleep 中的 this 一致</span>    <span class="hljs-comment">// 调用箭头函数</span>    <span class="hljs-title function_">fn</span>();&#125;&#125;<span class="hljs-comment">// 动态添加方法</span>user.<span class="hljs-property">sayHi</span> = sayHi<span class="hljs-comment">// 函数调用</span>user.<span class="hljs-title function_">sayHi</span>()</code></pre><p>在开发中【使用箭头函数前需要考虑函数中 <code>this</code> 的值】，<strong>事件回调函数</strong>使用箭头函数时，<code>this</code> 为全局的 <code>window</code>，因此DOM事件回调函数不推荐使用箭头函数，如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>)<span class="hljs-comment">// 箭头函数 此时 this 指向了 window</span>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)<span class="hljs-comment">// 普通函数 此时 this 指向了 DOM 对象</span>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)</code></pre><p>同样由于箭头函数 <code>this</code> 的原因，<strong>基于原型的面向对象也不推荐采用箭头函数</strong>，如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<span class="hljs-comment">// 原型对像上添加了箭头函数</span><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">walk</span> = <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125; <span class="hljs-comment">// window</span><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()p1.<span class="hljs-title function_">walk</span>()</code></pre><h3 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h3><p>以上归纳了普通函数和箭头函数中关于 <code>this</code> 默认值的情形，不仅如此 JavaScript 中还允许指定函数中 <code>this</code> 的指向，有 3 个方法可以动态指定普通函数中 <code>this</code> 的指向：</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<span class="hljs-keyword">let</span> student = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;<span class="hljs-comment">// 调用函数并指定 this 的值</span>sayHi.<span class="hljs-title function_">call</span>(user); <span class="hljs-comment">// this 值为 user</span>sayHi.<span class="hljs-title function_">call</span>(student); <span class="hljs-comment">// this 值为 student</span><span class="hljs-comment">// 求和函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;<span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-comment">// 调用 counter 函数，并传入参数</span><span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);</code></pre><p>总结：</p><ol><li><code>call</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li><li>使用 <code>call</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li><li><code>call</code> 方法的其余参数会依次自动传入函数做为函数的参数</li></ol><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;<span class="hljs-keyword">let</span> student = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小红&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">16</span>&#125;<span class="hljs-comment">// 调用函数并指定 this 的值</span>sayHi.<span class="hljs-title function_">apply</span>(user) <span class="hljs-comment">// this 值为 user</span>sayHi.<span class="hljs-title function_">apply</span>(student) <span class="hljs-comment">// this 值为 student</span><span class="hljs-comment">// 求和函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;  <span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-comment">// 调用 counter 函数，并传入参数</span><span class="hljs-keyword">let</span> result = counter.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>])</code></pre><p>总结：</p><ol><li><code>apply</code> 方法能够在调用函数的同时指定 <code>this</code> 的值</li><li>使用 <code>apply</code> 方法调用函数时，第1个参数为 <code>this</code> 指定的值</li><li><code>apply</code> 方法第2个参数为数组，数组的单元值依次自动传入函数做为函数的参数</li></ol><h4 id="bind（重点）"><a href="#bind（重点）" class="headerlink" title="bind（重点）"></a>bind（重点）</h4><p><code>bind</code> 方法并<strong>不会调用函数</strong>，而是创建一个指定了 <code>this</code> 值的新函数，使用方法如下代码所示：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 普通函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;<span class="hljs-keyword">let</span> user = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>,  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>&#125;<span class="hljs-comment">// 调用 bind 指定 this 的值</span><span class="hljs-keyword">let</span> sayHello = sayHi.<span class="hljs-title function_">bind</span>(user);<span class="hljs-comment">// 调用使用 bind 创建的新函数</span><span class="hljs-title function_">sayHello</span>()</code></pre><p>注：<code>bind</code> 方法创建新的函数，与原函数的唯一的变化是改变了 <code>this</code> 的值。</p><h2 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h2><ol><li>防抖（debounce）<br>  所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间</li></ol><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)    <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125; <span class="hljs-comment">// 如果里面存在大量操作 dom 的情况，会卡顿</span>    <span class="hljs-comment">// 防抖函数</span>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, t</span>) &#123;      <span class="hljs-keyword">let</span> timeId      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-comment">// 如果有定时器就清除</span>        <span class="hljs-keyword">if</span> (timeId) <span class="hljs-built_in">clearTimeout</span>(timeId)        <span class="hljs-comment">// 开启定时器 200</span>        timeId = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()&#125;, t)&#125;&#125;    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">debounce</span>(mouseMove, <span class="hljs-number">200</span>))</code></pre><ol start="2"><li>节流（throttle）<br>  所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数<pre><code class="hljs javascript"><span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)   <span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params"></span>) &#123;box.<span class="hljs-property">innerHTML</span> = ++i&#125;   <span class="hljs-comment">// 节流函数</span>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, t</span>) &#123;     <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;       <span class="hljs-comment">//如果没有定时器就创建定时器</span>       <span class="hljs-keyword">if</span> (!timer) &#123;         timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-title function_">fn</span>()           timer = <span class="hljs-literal">null</span> &#125;, t)&#125;&#125;&#125;   box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-title function_">throttle</span>(mouseMove, <span class="hljs-number">2000</span>))</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-处理this与节流防抖&quot;&gt;&lt;a href=&quot;#title-处理this与节流防抖&quot; class=&quot;headerlink&quot; title=&quot;title:处理this与节流防抖&quot;&gt;&lt;/a&gt;title:处理this与节流防抖&lt;/h2&gt;&lt;h2 id=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/03/%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/"/>
    <id>http://example.com/2023/04/03/%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</id>
    <published>2023-04-03T07:06:29.438Z</published>
    <updated>2023-04-05T01:29:47.114Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-拷贝与异常捕获"><a href="#title-拷贝与异常捕获" class="headerlink" title="title:拷贝与异常捕获"></a>title:拷贝与异常捕获</h2><h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><p>首先浅拷贝和深拷贝只针对引用类型</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝：拷贝的是地址</p><p>常见方法：</p><ol><li>拷贝对象：Object.assgin() &#x2F; 展开运算符 {…obj} 拷贝对象</li><li>拷贝数组：Array.prototype.concat() 或者 […arr]</li></ol><blockquote><p>如果是简单数据类型拷贝值，引用数据类型拷贝的是地址 。</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝：拷贝的是对象，不是地址</p><p>常见方法：</p><ol><li>通过递归实现深拷贝</li><li>lodash&#x2F;cloneDeep</li><li>通过JSON.stringify()实现</li></ol><h4 id="递归实现深拷贝"><a href="#递归实现深拷贝" class="headerlink" title="递归实现深拷贝"></a>递归实现深拷贝</h4><p>函数递归：由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;  <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,  <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],  <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;<span class="hljs-keyword">const</span> o = &#123;&#125;<span class="hljs-comment">// 拷贝函数</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">newObj, oldObj</span>) &#123;  <span class="hljs-keyword">debugger</span><span class="hljs-comment">//相当于断点调试</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> oldObj) &#123;    <span class="hljs-comment">// 处理数组的问题  一定先写数组 在写 对象 不能颠倒</span>    <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>) &#123;      newObj[k] = []      <span class="hljs-comment">//  newObj[k] 接收 []  hobby</span>      <span class="hljs-comment">//  oldObj[k]   [&#x27;乒乓球&#x27;, &#x27;足球&#x27;]</span>      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldObj[k] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>) &#123;      newObj[k] = &#123;&#125;      <span class="hljs-title function_">deepCopy</span>(newObj[k], oldObj[k])&#125;    <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//  k  属性名 uname age    oldObj[k]  属性值  18</span>      <span class="hljs-comment">// newObj[k]  === o.uname  给新对象添加属性</span>      newObj[k] = oldObj[k]&#125;&#125;&#125;<span class="hljs-title function_">deepCopy</span>(o, obj) <span class="hljs-comment">// 函数调用  两个参数 o 新对象  obj 旧对象</span>o.<span class="hljs-property">hobby</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;篮球&#x27;</span>o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">23</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</code></pre><h4 id="js库lodash里面cloneDeep内部实现了深拷贝"><a href="#js库lodash里面cloneDeep内部实现了深拷贝" class="headerlink" title="js库lodash里面cloneDeep内部实现了深拷贝"></a>js库lodash里面cloneDeep内部实现了深拷贝</h4><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">   <span class="hljs-keyword">const</span> obj = &#123;</span><span class="language-javascript">     <span class="hljs-attr">uname</span>: <span class="hljs-string">&#x27;pink&#x27;</span>,</span><span class="language-javascript">     <span class="hljs-attr">hobby</span>: [<span class="hljs-string">&#x27;乒乓球&#x27;</span>, <span class="hljs-string">&#x27;足球&#x27;</span>],</span><span class="language-javascript">     <span class="hljs-attr">family</span>: &#123;<span class="hljs-attr">baby</span>: <span class="hljs-string">&#x27;小pink&#x27;</span>&#125;&#125;</span><span class="language-javascript">   <span class="hljs-keyword">const</span> o = _.<span class="hljs-title function_">cloneDeep</span>(obj)</span><span class="language-javascript">   o.<span class="hljs-property">family</span>.<span class="hljs-property">baby</span> = <span class="hljs-string">&#x27;老pink&#x27;</span></span><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h4 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h4><pre><code class="hljs javascript"><span class="hljs-comment">// 把对象转换为 JSON 字符串</span><span class="hljs-keyword">const</span> o = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj))</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>异常处理是指预估代码执行过程中可能发生的错误，然后最大程度的避免错误的发生导致整个程序无法继续运行</p><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">counter</span>(<span class="hljs-params">x, y</span>) &#123;   <span class="hljs-keyword">if</span>(!x || !y) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数不能为空!&#x27;</span>)&#125;<span class="hljs-comment">// throw &#x27;参数不能为空!&#x27;;</span>   <span class="hljs-keyword">return</span> x + y&#125; <span class="hljs-title function_">counter</span>()</code></pre><p>总结：</p><ol><li><code>throw</code> 抛出异常信息，程序也会终止执行</li><li><code>throw</code> 后面跟的是错误提示信息</li><li><code>Error</code> 对象配合 <code>throw</code> 使用，能够设置更详细的错误信息</li></ol><h3 id="try-…-catch"><a href="#try-…-catch" class="headerlink" title="try … catch"></a>try … catch</h3><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;   <span class="hljs-keyword">try</span> &#123;     <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.p&#x27;</span>)     p.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>&#125;     <span class="hljs-keyword">catch</span> (error) &#123;     <span class="hljs-comment">// try 代码段中执行有错误时，会执行 catch 代码段</span>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)     <span class="hljs-comment">// 终止代码继续执行</span>     <span class="hljs-keyword">return</span>&#125;   <span class="hljs-keyword">finally</span> &#123;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;执行&#x27;</span>)&#125;     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;如果出现错误，我的语句不会执行&#x27;</span>)&#125; <span class="hljs-title function_">foo</span>()</code></pre><p>总结：</p><ol><li><code>try...catch</code> 用于捕获错误信息</li><li>将预估可能发生错误的代码写在 <code>try</code> 代码段中</li><li>如果 <code>try</code> 代码段中出现错误后，会执行 <code>catch</code> 代码段，并截获到错误信息</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-拷贝与异常捕获&quot;&gt;&lt;a href=&quot;#title-拷贝与异常捕获&quot; class=&quot;headerlink&quot; title=&quot;title:拷贝与异常捕获&quot;&gt;&lt;/a&gt;title:拷贝与异常捕获&lt;/h2&gt;&lt;h2 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/01/js%E5%8E%9F%E5%9E%8B/"/>
    <id>http://example.com/2023/04/01/js%E5%8E%9F%E5%9E%8B/</id>
    <published>2023-04-01T10:16:25.204Z</published>
    <updated>2023-04-03T01:47:50.423Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-JavaScript-原型"><a href="#title-JavaScript-原型" class="headerlink" title="title:JavaScript 原型"></a>title:JavaScript 原型</h2><h1 id="JavaScript-原型"><a href="#JavaScript-原型" class="headerlink" title="JavaScript 原型"></a>JavaScript 原型</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>对比以下通过面向对象的构造函数实现的封装：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;佚名&#x27;</span></span><span class="language-javascript">    <span class="hljs-comment">// 设置名字</span></span><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">setName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name</span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-comment">// 读取名字</span></span><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 实例对像，获得了构造函数中封装的所有逻辑</span></span><span class="language-javascript">  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span><span class="language-javascript">  p1.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&#x27;小明&#x27;</span>)</span><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>)</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 实例对象</span></span><span class="language-javascript">  <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">name</span>)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p><p>同样的将变量和函数组合到了一起并能通过 this 实现数据的共享，所不同的是借助构造函数创建出来的实例对象之</p><p>间是彼此不影响的</p><blockquote><p>总结：</p><ol><li>构造函数体现了面向对象的封装特性</li><li>构造函数实例创建的对象彼此独立、互不影响</li></ol></blockquote><p>封装是面向对象思想中比较重要的一部分，js面向对象可以通过构造函数实现的封装。</p><p>前面我们学过的构造函数方法很好用，但是 存在<code>浪费内存</code>的问题</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>构造函数通过原型分配的函数是所有对象所 共享的。</p><ul><li>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象，所以我们也称为原型对象</li><li>这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存</li><li>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</li><li>构造函数和原型对象中的this 都指向 实例化的对象</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    </span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 每个函数都有 prototype 属性</span></span><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>了解了 JavaScript 中构造函数与原型对象的关系后，再来看原型对象具体的作用，如下代码所示：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// 此处未定义任何方法</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 为构造函数的原型对象添加方法</span></span><span class="language-javascript">  <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi~&#x27;</span>);</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 实例化</span></span><span class="language-javascript">  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();</span><span class="language-javascript">  p1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出结果为 Hi~</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>构造函数 <code>Person</code> 中未定义任何方法，这时实例对象调用了原型对象中的方法 <code>sayHi</code>，接下来改动一下代码：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// 此处定义同名方法 sayHi</span></span><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;嗨!&#x27;</span>);</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 为构造函数的原型对象添加方法</span></span><span class="language-javascript">  <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi~&#x27;</span>);</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();</span><span class="language-javascript">  p1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出结果为 嗨!</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>构造函数 <code>Person</code> 中定义与原型对象中相同名称的方法，这时实例对象调用则是构造函中的方法 <code>sayHi</code>。</p><p>通过以上两个简单示例不难发现 JavaScript 中对象的工作机制：<strong>当访问对象的属性或方法时，先在当前实例对象是查找，然后再去原型对象查找，并且原型对象被所有实例共享。</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// 此处定义同名方法 sayHi</span></span><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;嗨!&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 为构造函数的原型对象添加方法</span></span><span class="language-javascript">  <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hi~&#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)</span><span class="language-javascript">  &#125;</span><span class="language-javascript">  <span class="hljs-comment">// 在构造函数的原型对象上添加属性</span></span><span class="language-javascript">  <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;小明&#x27;</span></span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span><span class="language-javascript">  p1.<span class="hljs-title function_">sayHi</span>(); <span class="hljs-comment">// 输出结果为 嗨!</span></span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span><span class="language-javascript">  p2.<span class="hljs-title function_">sayHi</span>()</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>总结：<strong>结合构造函数原型的特征，实际开发重往往会将封装的功能函数添加到原型对象中。</strong></p><h3 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h3><p>在哪里？ 每个原型对象里面都有个constructor 属性（constructor 构造函数）</p><p>作用：该属性指向该原型对象的构造函数， 简单理解，就是指向我的爸爸，我是有爸爸的孩子</p><p><strong>使用场景：</strong></p><p>如果有多个对象的方法，我们可以给原型对象采取对象形式赋值.</p><p>但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了</p><p>此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><p>对象都会有一个属性 <strong>proto</strong> 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype </p><p>原型对象的属性和方法，就是因为对象有 <strong>proto</strong> 原型的存在。</p><p>注意：</p><ul><li><strong>proto</strong> 是JS非标准属性</li><li>[[prototype]]和__proto__意义相同</li><li>用来表明当前实例对象指向哪个原型对象prototype</li><li>__proto__对象原型里面也有一个 constructor属性，指向创建该实例对象的构造函数</li></ul><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><p>继承是面向对象编程的另一个特征，通过继承进一步提升代码封装的程度，JavaScript 中大多是借助原型对象实现继承</p><p>的特性。</p><p>龙生龙、凤生凤、老鼠的儿子会打洞描述的正是继承的含义。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 继续抽取   公共的部分放到原型上</span></span><span class="language-javascript">    <span class="hljs-comment">// const Person1 = &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//   eyes: 2,</span></span><span class="language-javascript">    <span class="hljs-comment">//   head: 1</span></span><span class="language-javascript">    <span class="hljs-comment">// &#125;</span></span><span class="language-javascript">    <span class="hljs-comment">// const Person2 = &#123;</span></span><span class="language-javascript">    <span class="hljs-comment">//   eyes: 2,</span></span><span class="language-javascript">    <span class="hljs-comment">//   head: 1</span></span><span class="language-javascript">    <span class="hljs-comment">// &#125;</span></span><span class="language-javascript">    <span class="hljs-comment">// 构造函数  new 出来的对象 结构一样，但是对象不一样</span></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">eyes</span> = <span class="hljs-number">2</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-number">1</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-comment">// console.log(new Person)</span></span><span class="language-javascript">    <span class="hljs-comment">// 女人  构造函数   继承  想要 继承 Person</span></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Woman</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript"></span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-comment">// Woman 通过原型来继承 Person</span></span><span class="language-javascript">    <span class="hljs-comment">// 父构造函数（父类）   子构造函数（子类）</span></span><span class="language-javascript">    <span class="hljs-comment">// 子类的原型 =  new 父类  </span></span><span class="language-javascript">    <span class="hljs-title class_">Woman</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()   <span class="hljs-comment">// &#123;eyes: 2, head: 1&#125; </span></span><span class="language-javascript">    <span class="hljs-comment">// 指回原来的构造函数</span></span><span class="language-javascript">    <span class="hljs-title class_">Woman</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Woman</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 给女人添加一个方法  生孩子</span></span><span class="language-javascript">    <span class="hljs-title class_">Woman</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">baby</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;宝贝&#x27;</span>)</span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-keyword">const</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Woman</span>()</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(red)</span><span class="language-javascript">    <span class="hljs-comment">// console.log(Woman.prototype)</span></span><span class="language-javascript">    <span class="hljs-comment">// 男人 构造函数  继承  想要 继承 Person</span></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Man</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript"></span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-comment">// 通过 原型继承 Person</span></span><span class="language-javascript">    <span class="hljs-title class_">Man</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span><span class="language-javascript">    <span class="hljs-title class_">Man</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Man</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> pink = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Man</span>()</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pink)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且这种关联的关系是一种链状的结构，我们将原型对</p><p>象的链状结构关系称为原型链</p><p><img src="/assets/1676793388695.png" alt="67679338869"></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// function Objetc() &#123;&#125;</span></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript"></span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-keyword">const</span> ldh = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()</span><span class="language-javascript">    <span class="hljs-comment">// console.log(ldh.__proto__ === Person.prototype)</span></span><span class="language-javascript">    <span class="hljs-comment">// console.log(Person.prototype.__proto__ === Object.prototype)</span></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>)</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ldh <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>)</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>① 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。</p><p>② 如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）</p><p>③ 如果还没有就查找原型对象的原型（Object的原型对象）</p><p>④ 依此类推一直找到 Object 为止（null）</p><p>⑤ __proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线</p><p>⑥ 可以使用 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-JavaScript-原型&quot;&gt;&lt;a href=&quot;#title-JavaScript-原型&quot; class=&quot;headerlink&quot; title=&quot;title:JavaScript 原型&quot;&gt;&lt;/a&gt;title:JavaScript 原型&lt;/h2&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue属性</title>
    <link href="http://example.com/2023/03/28/vue%E5%B1%9E%E6%80%A7/"/>
    <id>http://example.com/2023/03/28/vue%E5%B1%9E%E6%80%A7/</id>
    <published>2023-03-28T07:01:14.117Z</published>
    <updated>2023-03-29T01:37:49.078Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue实例"><a href="#vue实例" class="headerlink" title="vue实例"></a>vue实例</h3><pre><code class="hljs vue">new Vue(&#123;&lt;!--vue渲染的对象 --&gt;   el: &#x27;#root&#x27;,&lt;!--存放数据属性 --&gt;   data: &#123;&#125;,&lt;!--函数属性 --&gt;   methods: &#123;&#125;,&lt;!--计算属性 --&gt;   computed: &#123;&#125;,&lt;!--侦听属性 --&gt;watch: &#123;&#125;&#125;)</code></pre><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><ol><li>单向绑定：v-bind:，v-bind：value等可简写为：value</li><li>双向绑定：v-model:,一般应用在表单类元素上，v-model:value可简写为v-model</li></ol><p>###VUE中的MVVM模型</p><ol><li><p>M是模型，Model：对应data中的数据。</p></li><li><p>V是视图，View：模板。</p></li><li><p>VM是视图模型，ViewModel:Vue的实例对象。</p><p>例如：</p><ul><li><p>网页就是View（DOM）</p></li><li><p>VUE实例就是ViewModel（DOM监听，数据绑定）</p></li><li><p>VUE实例中的数据就是Model（一般js对象）</p></li></ul></li></ol><h3 id="Object-defineProperrty-默认属性"><a href="#Object-defineProperrty-默认属性" class="headerlink" title="Object.defineProperrty 默认属性"></a>Object.defineProperrty 默认属性</h3><pre><code class="hljs javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperrty</span>(person,<span class="hljs-string">&#x27;age&#x27;</span>,&#123;    <span class="hljs-attr">value</span>:<span class="hljs-number">18</span>,    <span class="hljs-attr">enumberable</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//控制属性是否可以枚举，默认是false。</span>    <span class="hljs-attr">writable</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//控制属性是否可以被修改，默认值是false。</span>    <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span><span class="hljs-comment">//控制属性是否可以被删除，默认值是false。</span>    <span class="hljs-comment">//当有人读取person的age属性时，get函数（getter)就会被调用，且返回值就是age的值。</span>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> number&#125;,    <span class="hljs-comment">//当有人修改person的age属性时，set函数（setter)就会被调用，且会收到修改的具体值。</span>    <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>)&#123;number = value&#125;&#125;)</code></pre><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><pre><code class="hljs javascript"><span class="hljs-comment">//通过一个对象代理另一个对象中的属性的操作</span><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">100</span>&#125;<span class="hljs-keyword">let</span> obj2 = &#123;<span class="hljs-attr">y</span>:<span class="hljs-number">200</span>&#125;object.<span class="hljs-title function_">defineProperty</span>(obj2,<span class="hljs-string">&#x27;x&#x27;</span>,&#123;    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> obj.<span class="hljs-property">x</span>&#125;,    <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>)&#123;obj.<span class="hljs-property">x</span> = value&#125;&#125;)</code></pre><ol><li>Vue中的数据代理：通过VM对象来代理data对象中的属性操作（读写）</li><li>Vue中数据代理的好处：更加方便的操作data中的数据，不需要通过_ data.属性的方式调用，可以直接调用名字。</li><li>基本原理：通过object.defineProperty（）把data对象中所有属性添加到vm上。为每一个添加到vm上的属性，都指定一个getter和setter。在getter和setter内部去操作（读写）data中对应的属性。</li></ol><h3 id="事件修饰"><a href="#事件修饰" class="headerlink" title="事件修饰"></a>事件修饰</h3><pre><code class="hljs vue">&lt;!--阻止默认事件--&gt;例如@click.prevent,即preventDefault,会阻止标签自带的行为（例如a标签链接跳转）&lt;!--阻止冒泡--&gt;例如@click.stop,即stopPropagation,会阻止事件在父容器上再次触发。&lt;!--事件止触发一次--&gt;例如@click.once&lt;!--捕获模式--&gt;例如@click.capture,可以在捕获阶段触发函数，先捕获后冒泡&lt;!--只有event.target是当前操作的元素时才触发的事件--&gt;例如@click.self,也可以阻止冒泡&lt;!--事件的默认行为立即执行，无需等待事件回调执行完毕--&gt;@scroll:滚动条，@wheel：鼠标滚轮，后接.passive可以立即直接滚动，不会等着滚轮行为停止才开始滚动。</code></pre><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><pre><code class="hljs vue">&lt;!--@keydown--&gt;&lt;!--@keyup--&gt;&lt;!--别名的使用：--&gt;@keydown.enter&lt;!--常用别名:enter,delete,esc,space,tab(必须配合kedown),up,down,left,right,系统修饰键alt,ctrl，shift等配合kedown使用。--&gt;&lt;!--自定义别名：--&gt;&lt;!--Vue.config.keyCodes.自定义别名 = 键码--&gt;</code></pre><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性：需要的属性不存在，需要通过计算获得出来。原理：通过object.defineProperty（）方法提供的getter和setter方法实现。</p><p>优势：与methods实现相比内部有缓存机制（复用）效率更高，调试更方便。</p><pre><code class="hljs vue">computed: &#123;    fullName: &#123;      get() &#123;return this.firstName + &#x27;-&#x27; + this.lastName&#125;,      set() &#123;const arr = value.split(&#x27;-&#x27;)        this.firstName = arr[0]        this.lastName = arr[1]&#125;&#125;&#125;</code></pre><p>get的作用：当有人读取fullName时，get就会被调用，且返回值就作为fullName的值。</p><p>get什么时候被调用？1.初次读取fullName时，2.所依赖的数据发生变化时。</p><p>如果计算属性需要修改，那必须写set去响应修改，且set中要引起计算时以来的。</p><h3 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h3><pre><code class="hljs vue">watch: &#123;      ishot: &#123;deep:true,//深度监视，监视每一项内容        immediate: true,//初始化时调用一下handler        handler(newValue, oldValue) &#123;          console.log(&#x27;info被修改了&#x27;)&#125;&#125;&#125;</code></pre><p>vue中默认不监测对象内部的改变，配置deep可以检测对象内部的改变。</p><p>vue自身可以检测对象内部的改变，但是watch默认不检测。</p><h3 id="计算属性和侦听属性对比"><a href="#计算属性和侦听属性对比" class="headerlink" title="计算属性和侦听属性对比"></a>计算属性和侦听属性对比</h3><ol><li><p>计算属性和侦听属性都能完成的同样的功能</p></li><li><p>但是侦听可以完成异步操作，计算不行。</p></li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>所有不被vue管理的函数，写出箭头函数时，this才指向vm或者组件实例对象。</li><li>所有被vue管理的函数，最好写成普通函数，这样this才指向vm或者组件实例对象。</li></ol><h3 id="绑定样式"><a href="#绑定样式" class="headerlink" title="绑定样式"></a>绑定样式</h3><pre><code class="hljs vue"> &lt;!-- ：class,绑定calss样式 适用于样式的类名不确定，需要动态指定。--&gt;&lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;infos&#125;&#125;&lt;/div&gt; &lt;!-- ：style,绑定style样式 适用于样式的类名不确定，需要动态指定。--&gt;&lt;div style=&quot;basic&quot; :style=&quot;&#123;styleObj&#125;&quot;&gt;&#123;&#123;infos&#125;&#125;&lt;/div&gt;</code></pre><h3 id="条件渲染-列表渲染"><a href="#条件渲染-列表渲染" class="headerlink" title="条件渲染\列表渲染"></a>条件渲染\列表渲染</h3><ol><li><p>使用v-show做条件渲染，不显示时仍会渲染节点，时候频繁切换。</p></li><li><p>v-if也可以做条件渲染，不显示时完全不渲染，无法获取。（后面可以紧跟v-else-if、else不能分开），使用切换频率低的场景。</p></li><li><p>可以用template配合v-if,但不能和v-show配合</p></li><li><p>v-for&#x3D;’p in persons’类似for-in,需要绑定一个:key。可以遍历数组、对象、字符串（v-for&#x3D;’’of次数）</p><pre><code class="hljs vue">&lt;li v-for=&quot;p in persons&quot; :key=&#x27;p.id&#x27;&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt;</code></pre><p>key 的原理：数据变化时会在vue的虚拟dom里对比，相同的直接复用，不同的才加载。所以要用唯一标志。</p><h1 id="vue监视数据原理"><a href="#vue监视数据原理" class="headerlink" title="vue监视数据原理"></a>vue监视数据原理</h1><ol><li><p>vue会检测data中所有层次的数据。</p></li><li><p>如何监测对象中的数据？</p><p>​通过setter实现监视，且要在new Vue时就传入要检测的数据。</p><p>​（1）对象中后追加的属性，Vue默认不响应式处理</p><p>​（2）如需给后添加的属性做响应式，请使用如下API：</p><p>Vue.set(target.propertyName&#x2F;index.value)或</p><p>vm.$set(target.propertName&#x2F;index.value)</p></li><li><p>通过setter实现监视，且要在new Vue时就传入要检测的数据。</p><p>（1）对象中后追加的属性，Vue默认不响应式处理</p><p>（2）如需给后添加的属性做响应式，请使用如下API：</p><p>Vue.set(target.propertyName&#x2F;index.value)或</p><p>vm.$set(target.propertName&#x2F;index.value)</p></li><li><p>在vue修改数组中的某个元素用如下方法：</p><p>使用APIs:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p><p>特别注意Vue.set()、vm.$set()不能给vm的根数据对象添加属性</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;vue实例&quot;&gt;&lt;a href=&quot;#vue实例&quot; class=&quot;headerlink&quot; title=&quot;vue实例&quot;&gt;&lt;/a&gt;vue实例&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;hljs vue&quot;&gt;new Vue(&amp;#123;&amp;lt;!--vue渲染的对象 --&amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>移动页面判断正则表达式</title>
    <link href="http://example.com/2023/03/22/%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E6%AD%A3%E5%88%99/"/>
    <id>http://example.com/2023/03/22/%E7%A7%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E6%AD%A3%E5%88%99/</id>
    <published>2023-03-22T08:13:48.123Z</published>
    <updated>2023-03-23T13:20:31.766Z</updated>
    
    <content type="html"><![CDATA[<p>#navigator属性</p><p>常用属性和方法：navigator是对象，该对象下记录了浏览器自身的相关信息</p><ul><li>通过 userAgent 检测浏览器的版本及平台</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 检测 userAgent（浏览器信息）</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-keyword">const</span> userAgent = navigator.<span class="hljs-property">userAgent</span>  <span class="hljs-comment">// 验证是否为Android或iPhone</span>  <span class="hljs-keyword">const</span> android = userAgent.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)  <span class="hljs-keyword">const</span> iphone = userAgent.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/(iPhone\sOS)\s([\d_]+)/</span>)  <span class="hljs-comment">// 如果是Android或iPhone，则跳转至移动站点</span>  <span class="hljs-keyword">if</span> (android || iphone) &#123;    location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;http://m.itcast.cn&#x27;</span>  &#125;&#125;)();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#navigator属性&lt;/p&gt;
&lt;p&gt;常用属性和方法：navigator是对象，该对象下记录了浏览器自身的相关信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 userAgent 检测浏览器的版本及平台&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs javasc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>清除浮动带来的影响</title>
    <link href="http://example.com/2023/03/22/%E6%B8%85%E9%99%A4%E7%88%B6%E7%BA%A7%E7%9B%92%E5%AD%90%E6%B5%AE%E5%8A%A8/"/>
    <id>http://example.com/2023/03/22/%E6%B8%85%E9%99%A4%E7%88%B6%E7%BA%A7%E7%9B%92%E5%AD%90%E6%B5%AE%E5%8A%A8/</id>
    <published>2023-03-22T05:54:46.113Z</published>
    <updated>2023-03-23T13:21:01.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="清除浮动带来的影响"><a href="#清除浮动带来的影响" class="headerlink" title="清除浮动带来的影响"></a>清除浮动带来的影响</h1>   <pre><code class="hljs css"> <span class="hljs-comment">/*父子级标签，子浮动，父没有高度导致其他标准流元素布局会受影响*/</span> <span class="hljs-comment">/*1.直接加高度可以解决但是有时无法确定高度*/</span> <span class="hljs-comment">/*2.额外加一个div标签会复杂化页面结构*/</span> <span class="hljs-comment">/*3.单伪元素清除法，类写在父级元素上*/</span>     <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;         <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;.&#x27;</span>;         <span class="hljs-comment">/*伪元素是行内，清除浮动需要用块元素跟在父级后面*/</span>         <span class="hljs-attribute">display</span>: block;         <span class="hljs-attribute">clear</span>: both;         <span class="hljs-comment">/*兼容问题，避免老浏览器出现额外的边距等等*/</span>         <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;         <span class="hljs-attribute">visibility</span>:hidden;     &#125;      <span class="hljs-selector-class">.clearfix</span> &#123;          *zoom: <span class="hljs-number">1</span>;   <span class="hljs-comment">/*用于IE6,7兼容 */</span>      &#125; <span class="hljs-comment">/*4.双伪元素清除法，类写在父级元素上（同时解决塌陷和浮动影响）推荐*/</span> <span class="hljs-comment">/*.clearfix::before解决外边距塌陷问题*/</span>     <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::before</span>,     <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;         <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;         <span class="hljs-attribute">display</span>: table;     &#125;     <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123; <span class="hljs-attribute">clear</span>: both;     &#125;<span class="hljs-selector-class">.clearfix</span> &#123;          *zoom: <span class="hljs-number">1</span>;   <span class="hljs-comment">/*用于IE6,7兼容 */</span>      &#125; <span class="hljs-comment">/*5.overflow = hidden|auto|scroll 都可以实现，但是无法显示溢出元素*/</span> <span class="hljs-selector-class">.father</span> &#123;       <span class="hljs-attribute">overflow</span>: auto;     &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;清除浮动带来的影响&quot;&gt;&lt;a href=&quot;#清除浮动带来的影响&quot; class=&quot;headerlink&quot; title=&quot;清除浮动带来的影响&quot;&gt;&lt;/a&gt;清除浮动带来的影响&lt;/h1&gt;   &lt;pre&gt;&lt;code class=&quot;hljs css&quot;&gt; &lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/22/css%E5%88%B6%E4%BD%9C%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <id>http://example.com/2023/03/22/css%E5%88%B6%E4%BD%9C%E4%B8%89%E8%A7%92%E5%BD%A2/</id>
    <published>2023-03-22T03:54:37.886Z</published>
    <updated>2023-03-23T13:21:53.783Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="title-transparent的使用方法"><a href="#title-transparent的使用方法" class="headerlink" title="title:transparent的使用方法"></a>title:transparent的使用方法</h2><h1 id="transparent-指定透明度-使用方法"><a href="#transparent-指定透明度-使用方法" class="headerlink" title="transparent(指定透明度)使用方法"></a>transparent(指定透明度)使用方法</h1><ol><li><p>transparent的作用：在web前端中使用html+css用于制作三角形</p></li><li><p>盒子宽和高必须都为0,当设置一条边框有颜色，其他边框transparent时，会发现2边交接处是斜线，刚好和有颜色的底边形成一个三角形。</p></li><li><p>那个给transparent属性就说明他所在的位置要变成透明（隐藏起来），这时只会显示不透明的部分 （重点理解2自己再多操作几遍）</p></li></ol>  <pre><code class="hljs css"><span class="hljs-comment">/*顶部倒三角形 ：只留想让显示的部分，其余的用transparent隐藏其与之相邻的两条边*/</span>  <span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">30px</span> solid red ;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">30px</span> solid transparent;  <span class="hljs-attribute">border-right</span>:<span class="hljs-number">30px</span> solid transparent;  &#125;    <span class="hljs-comment">/*左侧三角形 */</span>  <span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">30px</span> solid transparent;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">30px</span> solid red;  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">30px</span> solid transparent;  &#125;    <span class="hljs-comment">/*右侧三角形*/</span>  <span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-right</span>:<span class="hljs-number">30px</span> solid red;  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">30px</span> solid transparent;  <span class="hljs-attribute">border-top</span>:<span class="hljs-number">30px</span> solid transparent;  &#125;    <span class="hljs-comment">/*底部正三角形*/</span>  <span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>;  <span class="hljs-attribute">border-bottom</span>:<span class="hljs-number">30px</span> solid red;  <span class="hljs-attribute">border-left</span>:<span class="hljs-number">30px</span> solid transparent;  <span class="hljs-attribute">border-right</span>:<span class="hljs-number">30px</span> solid transparent;  &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;title-transparent的使用方法&quot;&gt;&lt;a href=&quot;#title-transparent的使用方法&quot; class=&quot;headerlink&quot; title=&quot;title:transparent的使用方法&quot;&gt;&lt;/a&gt;title:transpare</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>事件委托与冒泡</title>
    <link href="http://example.com/2023/03/20/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%B8%8E%E5%86%92%E6%B3%A1/"/>
    <id>http://example.com/2023/03/20/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%B8%8E%E5%86%92%E6%B3%A1/</id>
    <published>2023-03-20T01:45:16.311Z</published>
    <updated>2023-03-23T13:18:04.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件委托与冒泡"><a href="#事件委托与冒泡" class="headerlink" title="事件委托与冒泡"></a>事件委托与冒泡</h1><ul><li>掌握阻止事件冒泡的方法</li><li>理解事件委托的实现原理</li></ul><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度。任意事件被触发时总会经历两个阶段：【捕获阶段】和【冒泡阶段】。</p><p>简言之，捕获阶段是【从父到子】的传导过程，冒泡阶段是【从子向父】的传导过程。</p><h3 id="捕获和冒泡"><a href="#捕获和冒泡" class="headerlink" title="捕获和冒泡"></a>捕获和冒泡</h3><p>了解了什么是事件流之后，我们来看事件流是如何影响事件执行的：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>事件流<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 获取嵌套的3个节点</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.outer&#x27;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.inner&#x27;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.child&#x27;</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// html 元素添加事件</span></span><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;html...&#x27;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// body 元素添加事件</span></span><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;body...&#x27;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 外层的盒子添加事件</span></span><span class="language-javascript">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;outer...&#x27;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    </span><span class="language-javascript">    <span class="hljs-comment">// 中间的盒子添加事件</span></span><span class="language-javascript">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;inner...&#x27;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">    </span><span class="language-javascript">    <span class="hljs-comment">// 内层的盒子添加事件</span></span><span class="language-javascript">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child...&#x27;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>执行上述代码后发现，当单击事件触发时，其祖先元素的单击事件也【相继触发】，这是为什么呢？</p><p>结合事件流的特征，我们知道当某个元素的事件被触发时，事件总是会先经过其祖先才能到达当前元素，然后再由当前元素向祖先传递，事件在流动的过程中遇到相同的事件便会被触发。</p><p>再来关注一个细节就是事件相继触发的【执行顺序】，事件的执行顺序是可控制的，即可以在捕获阶段被执行，也可以在冒泡阶段被执行。</p><p>如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式。</p><p>如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>事件流<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>事件流是事件在执行时的底层机制，主要体现在父子盒子之间事件的执行上。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 获取嵌套的3个节点</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.outer&#x27;</span>)</span><span class="language-javascript">    <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.inner&#x27;</span>)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 外层的盒子</span></span><span class="language-javascript">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;outer...&#x27;</span>)</span><span class="language-javascript">    &#125;, <span class="hljs-literal">true</span>) <span class="hljs-comment">// true 表示在捕获阶段执行事件</span></span><span class="language-javascript">    </span><span class="language-javascript">    <span class="hljs-comment">// 中间的盒子</span></span><span class="language-javascript">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;inner...&#x27;</span>)</span><span class="language-javascript">    &#125;, <span class="hljs-literal">true</span>)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>结论：</p><ol><li><code>addEventListener</code> 第3个参数决定了事件是在捕获阶段触发还是在冒泡阶段触发</li><li><code>addEventListener</code> 第3个参数为  <code>true</code> 表示捕获阶段触发，<code>false</code> 表示冒泡阶段触发，默认值为 <code>false</code></li><li>事件流只会在父子元素具有相同事件类型时才会产生影响</li><li>绝大部分场景都采用默认的冒泡模式（其中一个原因是早期 IE 不支持捕获）</li></ol><h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>阻止冒泡<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 获取嵌套的3个节点</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> outer = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.outer&#x27;</span>)</span><span class="language-javascript">    <span class="hljs-keyword">const</span> inner = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.inner&#x27;</span>)</span><span class="language-javascript">    <span class="hljs-keyword">const</span> child = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.child&#x27;</span>)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 外层的盒子</span></span><span class="language-javascript">    outer.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;outer...&#x27;</span>)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 中间的盒子</span></span><span class="language-javascript">    inner.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;inner...&#x27;</span>)</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-comment">// 阻止事件冒泡</span></span><span class="language-javascript">      ev.<span class="hljs-title function_">stopPropagation</span>()</span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 内层的盒子</span></span><span class="language-javascript">    child.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;child...&#x27;</span>)</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-comment">// 借助事件对象，阻止事件向上冒泡</span></span><span class="language-javascript">      ev.<span class="hljs-title function_">stopPropagation</span>()</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>结论：事件对象中的 <code>ev.stopPropagation</code> 方法，专门用来阻止事件冒泡。（本质是阻断事件流动传播）</p><blockquote><p>鼠标经过事件：</p><p>mouseover 和 mouseout 会有冒泡效果</p><p>mouseenter  和 mouseleave   没有冒泡效果 (推荐)</p></blockquote><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托是利用事件流的特征解决一些现实开发需求的知识技巧，主要的作用是提升程序效率。</p><p>大量的事件监听是比较耗费性能的，如下代码所示</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 假设页面中有 10000 个 button 元素</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;table button&#x27;</span>);</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= buttons.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// 为 10000 个 button 元素添加了事件</span></span><span class="language-javascript">    buttons.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 省略具体执行逻辑...</span></span><span class="language-javascript">    &#125;)</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>利用事件流的特征，可以对上述的代码进行优化，事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化，如下代码所示：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 假设页面中有 10000 个 button 元素</span></span><span class="language-javascript">  <span class="hljs-keyword">let</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;table button&#x27;</span>);</span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-comment">// 假设上述的 10000 个 buttom 元素共同的祖先元素是 table</span></span><span class="language-javascript">  <span class="hljs-keyword">let</span> parents = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;table&#x27;</span>);</span><span class="language-javascript">  parents.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;点击任意子元素都会触发事件...&#x27;</span>);</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>我们的最终目的是保证只有点击 button 子元素才去执行事件的回调函数，如何判断用户点击是哪一个子元素呢？</p><p>事件对象中的属性 <code>target</code> 或 <code>srcElement</code>属性表示真正触发事件的元素，它是一个元素类型的节点。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 假设页面中有 10000 个 button 元素</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> buttons = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;table button&#x27;</span>)</span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-comment">// 假设上述的 10000 个 buttom 元素共同的祖先元素是 table</span></span><span class="language-javascript">  <span class="hljs-keyword">const</span> parents = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;table&#x27;</span>)</span><span class="language-javascript">  parents.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// console.log(ev.target);</span></span><span class="language-javascript">    <span class="hljs-comment">// 只有 button 元素才会真正去执行逻辑</span></span><span class="language-javascript">    <span class="hljs-keyword">if</span>(ev.<span class="hljs-property">target</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;BUTTON&#x27;</span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 执行的逻辑</span></span><span class="language-javascript">    &#125;</span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>优化过的代码只对祖先元素添加事件监听，相比对 10000 个元素添加事件监听执行效率要高许多！！！</p><h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><p>加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件</p><p>有些时候需要等页面资源全部处理完了做一些事情</p><p><strong>事件名：load</strong></p><p>监听页面所有资源加载完毕：</p><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// xxxxx</span>&#125;)<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>等<span class="hljs-variable constant_">DOM</span>加载完毕，就加载事件（更快）</code></pre><h3 id="元素滚动事件"><a href="#元素滚动事件" class="headerlink" title="元素滚动事件"></a>元素滚动事件</h3><p>滚动条在滚动的时候持续触发的事件</p><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;     <span class="hljs-comment">// 必须写到里面</span>    <span class="hljs-comment">//获取页面html元素的写法documentElement</span>     <span class="hljs-keyword">const</span> n = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>      <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">100</span>) &#123;        div.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;block&#x27;</span>      &#125; <span class="hljs-keyword">else</span> &#123;        div.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>      &#125;      <span class="hljs-comment">// 得到数据是数字型 不带单位</span>&#125;)</code></pre><h3 id="页面尺寸事件"><a href="#页面尺寸事件" class="headerlink" title="页面尺寸事件"></a>页面尺寸事件</h3><p>会在窗口尺寸改变的时候触发事件：   </p><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;    <span class="hljs-comment">// xxxxx</span>&#125;)</code></pre><h2 id="元素尺寸与位置"><a href="#元素尺寸与位置" class="headerlink" title="元素尺寸与位置"></a>元素尺寸与位置</h2><p>获取元素的自身宽高、包含元素自身设置的宽高、padding、border: offsetWidth和offsetHeight，</p><p>offsetTop,offsetleft ,以带有定位的父级，或者是文档左上角为准。 </p><p>获取出来的是数值,方便计算</p><p>注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件委托与冒泡&quot;&gt;&lt;a href=&quot;#事件委托与冒泡&quot; class=&quot;headerlink&quot; title=&quot;事件委托与冒泡&quot;&gt;&lt;/a&gt;事件委托与冒泡&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;掌握阻止事件冒泡的方法&lt;/li&gt;
&lt;li&gt;理解事件委托的实现原理&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo更换主题不生效</title>
    <link href="http://example.com/2023/03/19/hexoUseGuide/"/>
    <id>http://example.com/2023/03/19/hexoUseGuide/</id>
    <published>2023-03-19T05:16:27.534Z</published>
    <updated>2023-03-19T06:11:36.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客-Next更换修改主题样式-不生效的解决"><a href="#Hexo博客-Next更换修改主题样式-不生效的解决" class="headerlink" title="Hexo博客 Next更换修改主题样式 不生效的解决"></a>Hexo博客 Next更换修改主题样式 不生效的解决</h1><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>在对下面的Next主题样式修改时候，博客站点可能无法正常生效。</p><pre><code class="hljs plaintext"># Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini</code></pre><blockquote><p>解决方法：</p></blockquote><blockquote><blockquote><p>1.在git bash中进入hexo目录，执行</p></blockquote></blockquote><pre><code class="hljs plaintext">hexo clean</code></pre><p>后 再执行</p><pre><code class="hljs plaintext">hexo g -d</code></pre><blockquote><blockquote><p>2.浏览器清除缓存</p></blockquote></blockquote><blockquote><blockquote><p>3.刷新页面即可生效</p></blockquote></blockquote><p><a href="https://zhangshao7.github.io/tags/hexo/"># hexo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo博客-Next更换修改主题样式-不生效的解决&quot;&gt;&lt;a href=&quot;#Hexo博客-Next更换修改主题样式-不生效的解决&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客 Next更换修改主题样式 不生效的解决&quot;&gt;&lt;/a&gt;Hexo博客 N</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo发布流程</title>
    <link href="http://example.com/2023/03/19/hexoCommand/"/>
    <id>http://example.com/2023/03/19/hexoCommand/</id>
    <published>2023-03-19T05:16:27.531Z</published>
    <updated>2023-03-19T05:17:00.724Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="hljs bash"><span class="hljs-comment"># 生成静态网站文件</span>hexo g  <span class="hljs-comment"># 上传到远程仓库</span>hexo d  <span class="hljs-comment"># 1、清除 hexo 的缓存</span>hexo clean<span class="hljs-comment"># 2、采用一键部署</span>hexo g --d123456789</code></pre><p>可以直接到根目录 &#x2F;source&#x2F;_posts 目录下，创建一个.md 文件进行编写，在文件的顶部添加下面内容就可以了，主要写一个 title 就好了，其他都可以省略</p><hr><p>title: 文章名称<br>date: 2020-07-30 16:46:07(创建时间)<br>tags: 标签名<br>categories: 分类<br>description: 描述<br>comments: 是否开启评论(true or false)</p><p>之后，使用 <strong>hexo g –d</strong> 命令推送到 gitee上，并在 gitee 上更新一下 Gitee Pages 服务即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# 生成静态网站文件&lt;/span&gt;
hexo g  
&lt;span class=&quot;hljs-comment&quot;&gt;# 上传到远程仓库&lt;/span&gt;
hexo d  

&lt;sp</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>web基础</title>
    <link href="http://example.com/2023/03/19/webFoundation/"/>
    <id>http://example.com/2023/03/19/webFoundation/</id>
    <published>2023-03-19T03:37:31.426Z</published>
    <updated>2023-03-23T13:27:00.911Z</updated>
    
    <content type="html"><![CDATA[<p>#语义化</p><ul><li><p>网页后缀为html</p></li><li><p>标签语义化</p></li><li><p>SEO三大标签：<title>，<meta>（description，keywords）；</p></li><li><p>标签icon：<link href="favicon.ico"></p></li></ul><h1 id="CSS书写顺序"><a href="#CSS书写顺序" class="headerlink" title="CSS书写顺序"></a>CSS书写顺序</h1><p>这种顺序可以使得网页加载更加流畅迅速。 </p><ul><li><p>浮动&#x2F;display</p></li><li><p>盒子模型的长宽高边距背景等属性。</p></li><li><p>文字样式</p></li></ul><h1 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 position</h1><h2 id="子绝父相。"><a href="#子绝父相。" class="headerlink" title="子绝父相。"></a>子绝父相。</h2><ul><li>相对定位：relative。占有原来的位置，相对自己原来的位置移动。div仍独占一行，类推。</li><li>绝对定位：absolute。先找已经定位的父级，参照父级定位，父级没定位参照浏览器窗口定位。脱标，不占位。</li></ul><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><pre><code class="hljs css"><span class="hljs-number">1</span><span class="hljs-selector-class">.margin</span>:<span class="hljs-number">0</span> auto;<span class="hljs-comment">/*绝对定位以后用第一条定位无效，因为脱标了。*/</span><span class="hljs-number">2</span><span class="hljs-selector-class">.position</span>:absolute;<span class="hljs-comment">/*移动到了浏览器偏右边的位置*/</span><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<span class="hljs-comment">/*移动到中间中间偏下的位置*/</span><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<span class="hljs-comment">/*移动到中间位置*/</span><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);</code></pre><h3 id="显示层级"><a href="#显示层级" class="headerlink" title="显示层级"></a>显示层级</h3><ul><li><p>标准流&lt;浮动&lt;定位（底部&lt;顶部）</p></li><li><p>定位的情况下，后来者居上。</p></li><li><p>定位的情况下，使用z-index属性：取值越大显示越靠上。（默认值是0）</p></li></ul><p>##2.8 装饰</p><h3 id="2-8-1-垂直对齐方式"><a href="#2-8-1-垂直对齐方式" class="headerlink" title="2.8.1 垂直对齐方式"></a>2.8.1 垂直对齐方式</h3><p><strong>vertical-align属性</strong></p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>baseline</td><td>默认，基线对齐</td></tr><tr><td>top</td><td>顶部对齐</td></tr><tr><td>middle</td><td>中部对齐</td></tr><tr><td>bottom</td><td>底部对齐</td></tr></tbody></table><ul><li><p>行内和行内块标签默认按基线对齐的，去middle对齐。把行内变成块也可以解决。</p></li><li><p>想让行内和行内块水平居中和文字居中方式一样text-align。（浏览器均当作文字处理）</p></li></ul><h3 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h3><ol><li><p>创建一个盒子，设置盒子的尺寸和小图的尺寸相同。</p></li><li><p>将精灵图设置为盒子的背景图片。</p></li><li><p>修改背景图片的位置，设置每个小div的&#x3D;&#x3D;background-position: x y。&#x3D;&#x3D;</p></li></ol><h2 id="2-9-平面转换-transform属性"><a href="#2-9-平面转换-transform属性" class="headerlink" title="2.9 平面转换 transform属性"></a>2.9 平面转换 transform属性</h2><pre><code class="hljs css"><span class="hljs-comment">/*位移*/</span><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(x水平,y垂直);<span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate3d</span>(x水平,y垂直，z);<span class="hljs-comment">/*透视，配合translate实现z轴展示*/</span><span class="hljs-attribute">perspective</span>：<span class="hljs-number">800</span>-<span class="hljs-number">1200px</span>;<span class="hljs-comment">/*默认水平移动*/</span><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translate</span>(<span class="hljs-number">50px</span>);<span class="hljs-comment">/*垂直移动*/</span><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateY</span>(<span class="hljs-number">50px</span>);<span class="hljs-comment">/*双开门动画*/</span>可以用伪类加精灵图的方式实现。https://www.bilibili.com/video/BV1xq4y1q7jZ/?p=<span class="hljs-number">14</span>&amp;share_source=copy_web&amp;vd_source=<span class="hljs-number">4424</span>da35f5598c7a4ce84ace48dec503<span class="hljs-comment">/*旋转效果写在hover伪类上 要配合过渡属性*/</span>transform:<span class="hljs-built_in">rotate</span>(<span class="hljs-number">360deg</span>);<span class="hljs-comment">/*围绕z轴就是2维旋转效果，x轴横向旋转和y轴纵向旋转，3d自定义旋转*/</span><span class="hljs-attribute">transform</span>:rotatex/y/z/<span class="hljs-number">3</span><span class="hljs-built_in">d</span>(<span class="hljs-number">360deg</span>);<span class="hljs-comment">/*转换原点写在原标签上*/</span><span class="hljs-attribute">transform-origin</span>：<span class="hljs-attribute">left</span> <span class="hljs-attribute">top</span> <span class="hljs-attribute">right</span> <span class="hljs-attribute">bottom</span> center<span class="hljs-comment">/*多个转换先写位移后旋转否则改变坐标轴向*/</span><span class="hljs-comment">/*缩放*/</span><span class="hljs-attribute">transform</span>:<span class="hljs-built_in">scale</span>(<span class="hljs-number">1</span>);大于<span class="hljs-number">1</span>放大，反之缩小。<span class="hljs-comment">/*立体，让子元素3d呈现*/</span><span class="hljs-attribute">transform-style</span>:preserve-<span class="hljs-number">3</span>d;</code></pre><h2 id="2-11-Flex布局"><a href="#2-11-Flex布局" class="headerlink" title="2.11 Flex布局"></a>2.11 Flex布局</h2><p>###2.11.1 轴对齐布局</p><pre><code class="hljs css"><span class="hljs-comment">/*流式布局*/</span><span class="hljs-attribute">width</span>:<span class="hljs-number">100%</span>height:固定px;<span class="hljs-comment">/*Flex（弹性）布局一般加在父级上*/</span><span class="hljs-attribute">display</span>: flex;<span class="hljs-comment">/*主轴对齐方式 添加父级上*/</span><span class="hljs-attribute">justify-content</span>: <span class="hljs-comment">/*居中*/</span>center <span class="hljs-comment">/*间距加载子级的两侧*/</span>space-around <span class="hljs-comment">/*间距在盒子子级之间*/</span>space-beteween <span class="hljs-comment">/*所有地方间距都相等*/</span>space-evenly;<span class="hljs-comment">/*侧轴对齐方式 添加父级上*/</span><span class="hljs-attribute">align-items</span>:<span class="hljs-comment">/*居中*/</span>center<span class="hljs-comment">/*拉伸（默认效果）*/</span>stretch;<span class="hljs-comment">/*单独设置某个弹性盒子的侧轴对齐方式*/</span><span class="hljs-attribute">align-self</span>: center;<span class="hljs-comment">/*以上父级flex的情况下，没有其他设置子级高度和父级一致*/</span></code></pre><p>##2.12 移动端适配<br>###2.12.1 使用媒体查询差异化css样式</p><pre><code class="hljs css"> <span class="hljs-comment">/*@media(媒体特性)&#123;</span><span class="hljs-comment">    选择器&#123;</span><span class="hljs-comment">      css属性</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">   &#125;</span><span class="hljs-comment">1.HTML标签添加字号 1/10；</span><span class="hljs-comment">2.写rem单位的尺寸；</span><span class="hljs-comment">设计稿375px，字号37.5px</span><span class="hljs-comment">rem=内容的px/37.5px；</span><span class="hljs-comment">*/</span> orientation：判断屏幕方向。<span class="hljs-attribute">max-width</span>:表示最大值，要小于这个值。（从大到小写）min-width:表示最小值，要大于这个值。（从小到大写）高也有类似的属性但一般不用。<span class="hljs-comment">/*视口的宽小于等于768px背景色是粉色*/</span>@<span class="hljs-built_in">media</span>(max-width：<span class="hljs-number">768px</span>)&#123;    <span class="hljs-selector-tag">html</span>&#123;      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">37.5px</span>;          &#125;&#125;<span class="hljs-comment">/*要按照数字的大小写，否则只生效最大或最小的属性。*/</span>现在可以使用手机淘宝的flexible<span class="hljs-selector-class">.js</span>来适配。完整写法：<span class="hljs-keyword">@media</span> 关键词 媒体类型 <span class="hljs-keyword">and</span> (媒体特性)&#123;css&#125; .关键词: and only not .媒体类型： screen print speech <span class="hljs-built_in">all</span>(几乎不用)<span class="hljs-comment">/*还可与用link标签写法*/</span>&lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> media=<span class="hljs-string">&quot;逻辑符 媒体类型 and (媒体特性)&quot;</span> href=<span class="hljs-string">&quot;xx.css&quot;</span>&gt;注意没有@符号<span class="hljs-comment">/*隐藏*/</span>当页面小于一定值，在媒体查询里面写&#123;<span class="hljs-attribute">display</span>：<span class="hljs-attribute">none</span>&#125;用于隐藏一些组件。</code></pre><h3 id="2-13-Less语法"><a href="#2-13-Less语法" class="headerlink" title="2.13 Less语法"></a>2.13 Less语法</h3><ul><li>Less是一个css的预处理器。</li><li>使用Less可以完成px到rem的单位转换，以及更清晰的CSS目录结构。</li></ul><pre><code class="hljs less"><span class="hljs-comment">//注释内容，这是单行注释，尽量别用css看不见</span><span class="hljs-comment">/*多行注释*/</span><span class="hljs-comment">/*除法*/</span><span class="hljs-attribute">width</span>:(<span class="hljs-number">68</span> / <span class="hljs-number">37.5rem</span>);<span class="hljs-comment">/*嵌套写法*/</span>.父级选择器&#123;    <span class="hljs-comment">//父级样式</span>    .子级选择器&#123;       <span class="hljs-comment">//子级样式 </span>    &#125;&#125;<span class="hljs-selector-tag">&amp;</span>符号，例如子集里的<span class="hljs-selector-tag">&amp;</span>：<span class="hljs-selector-tag">hover</span>，就只会生产子集里的 .子集：<span class="hljs-selector-tag">hover</span>@符号，类似<span class="hljs-selector-tag">C</span>中的<span class="hljs-selector-tag">define</span>；@<span class="hljs-selector-tag">Colora</span>：<span class="hljs-selector-tag">pink</span>;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">color</span>:<span class="hljs-variable">@Colora</span>;&#125;<span class="hljs-comment">/*引入其他less文件*/</span><span class="hljs-keyword">@import</span><span class="hljs-string">&#x27;./1.less&#x27;</span>; 配置<span class="hljs-selector-tag">less</span>导出路径：<span class="hljs-number">1</span><span class="hljs-selector-class">.EasyLess</span>插件的<span class="hljs-selector-tag">setting</span>里设置： &quot;<span class="hljs-selector-tag">less</span><span class="hljs-selector-class">.compile</span>&quot;: &#123;        &quot;<span class="hljs-selector-tag">out</span>&quot;:&quot;./<span class="hljs-selector-tag">css</span>/&quot;        &#125;<span class="hljs-number">2</span><span class="hljs-selector-class">.less</span>文件内指定路径：<span class="hljs-comment">//out:./abc/</span><span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">color</span>: aliceblue;&#125;<span class="hljs-number">3</span>.禁止导出：<span class="hljs-comment">//out:false</span>        </code></pre><h3 id="2-14-vw-x2F-vh移动适配效果"><a href="#2-14-vw-x2F-vh移动适配效果" class="headerlink" title="2.14 vw&#x2F;vh移动适配效果"></a>2.14 vw&#x2F;vh移动适配效果</h3><p>vw: viewport width 视口的宽度，1vw &#x3D; 1&#x2F;100视口宽度</p><p>vh: viewport height 视口的高度   1vh &#x3D; 1&#x2F;100视口高度</p><p>例如 375px*687px宽的   宽 &#x3D; （68&#x2F;3.75px）高 </p><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><pre><code class="hljs javascript"><span class="hljs-comment">/* 存在 title 属性的 &lt;a&gt; 元素 */</span>a[title] &#123;  <span class="hljs-attr">color</span>: purple;&#125;<span class="hljs-comment">/* 存在 href 属性并且属性值匹配&quot;https://example.org&quot;的 &lt;a&gt; 元素 */</span>a[href=<span class="hljs-string">&quot;https://example.org&quot;</span>] &#123;  <span class="hljs-attr">color</span>: green;&#125;<span class="hljs-comment">/* 存在 href 属性并且属性值包含&quot;example&quot;的 &lt;a&gt; 元素 */</span>a[href*=<span class="hljs-string">&quot;example&quot;</span>] &#123;  font-<span class="hljs-attr">size</span>: 2em;&#125;<span class="hljs-comment">/* 存在 href 属性并且属性值结尾是&quot;.org&quot;的 &lt;a&gt; 元素 */</span>a[href$=<span class="hljs-string">&quot;.org&quot;</span>] &#123;  font-<span class="hljs-attr">style</span>: italic;&#125;<span class="hljs-comment">/* 存在 class 属性并且属性值包含单词&quot;logo&quot;的&lt;a&gt;元素 */</span>a[<span class="hljs-keyword">class</span>~=<span class="hljs-string">&quot;logo&quot;</span>] &#123;  <span class="hljs-attr">padding</span>: 2px;&#125;</code></pre><h1 id="3-JS笔记"><a href="#3-JS笔记" class="headerlink" title="3.JS笔记"></a>3.JS笔记</h1><h2 id="3-1-基础语法"><a href="#3-1-基础语法" class="headerlink" title="3.1 基础语法"></a>3.1 基础语法</h2><h3 id="3-1-1-变量、常量、关键字"><a href="#3-1-1-变量、常量、关键字" class="headerlink" title="3.1.1 变量、常量、关键字"></a>3.1.1 变量、常量、关键字</h3><ol><li>var 可以先使用再声明（不合理）</li><li>var声明过的变量可以重复声明（不合理）比如变量提升，全局变量，没有块级作用域。</li><li>日常开发一般用let声明变量。</li><li>const用来定义常量，不允许更改，声明时必须赋值。</li><li>&#x3D;&#x3D;有了变量优先用const声明，如果发现需要修改再改成let，建议数组和对象用const&#x3D;&#x3D;</li><li>模板字符串：<code>我叫$&#123;name&#125;</code>(用反引号包裹住，方便拼接字符串)</li><li>隐式转换：除了+以外的算术运算符都会把数据转换成数字类型。任何数据和字符串相加结果都是字符串。</li><li>运算符优先级（!&gt;&amp;&amp;&gt;||)<img src="D:\编程练习题目\web\image\image-20230301205305740.png"></li></ol><p>###3.1.2 数组</p><p>####添加数据</p><ul><li><p>arr.push()：将新数据添加到数组后面。</p></li><li><p>arr.unshift()：将新数据添加到数组第一个元素。</p></li></ul><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><p>arr.pop()：删除数字最后一个元素。</p></li><li><p>arr.shift():删除第一个元素。</p></li><li><p>arr.splice(操作起始下标，删除个数)，例如arr.splice(1)，从第一个删到最后。</p></li><li><ol start="2"><li>添加  数组.splice(起始位置, 删除个数, 添加的元素)</li></ol><p>  &#x2F;&#x2F; 把 pink 放到 red 和 green中间</p><p>  &#x2F;&#x2F; 起始位置 要放到的索引号位置</p><p>  &#x2F;&#x2F; arr.splice(1, 0, ‘pink’)</p></li></ul><h2 id="3-2-函数"><a href="#3-2-函数" class="headerlink" title="3.2 函数"></a>3.2 函数</h2><p>###3.2.1 函数声明</p><pre><code class="hljs javascript">具名函数：<span class="hljs-keyword">function</span> 函数名(形式参数列表)&#123;      函数体    &#125;;函数名(传递的现实参数)可以给形参一个默认值，这样程序更严谨。不会出现<span class="hljs-literal">undefined</span>。匿名函数：<span class="hljs-number">1.</span>函数表达式：<span class="hljs-keyword">let</span> fn = <span class="hljs-keyword">function</span>(<span class="hljs-params">参数</span>)&#123;    函数体&#125;函数表达式必须先声明后调用<span class="hljs-number">2.</span>立即执行函数：第一种写法：(<span class="hljs-keyword">function</span>(<span class="hljs-params">形参</span>)&#123;函数体&#125;)(实参);第二种写法：(<span class="hljs-keyword">function</span>(<span class="hljs-params">形参</span>)&#123;函数体&#125;(实参));必须要加分号作为结尾符。</code></pre><h3 id="3-2-2-作用域"><a href="#3-2-2-作用域" class="headerlink" title="3.2.2 作用域"></a>3.2.2 作用域</h3><p>####作用域</p><ol><li><p>全局作用域：作用于整个<script>标签内的，或是独立的js文件。</p><ul><li>全局变量：函数外的let变量，在任何区域都可以访问和修改。</li></ul></li><li><p>局部作用域：作用于函数的内部。</p><ul><li>局部变量：只在当前函数内部访问和修改。</li></ul></li><li><p>如果函数内部，变量没有声明直接赋值也当全局变量来看（不推荐）。</p></li></ol><p>####逻辑中断</p><pre><code class="hljs javascript">&amp;&amp;:左边为<span class="hljs-literal">false</span>就短路。两边都是<span class="hljs-literal">true</span>则最后一个真值。||:左边为<span class="hljs-literal">true</span>就短路。两边都是<span class="hljs-literal">true</span>则返回第一个真值。运算结果都是最后被执行的表达式值，一般用在变量赋值。</code></pre><p>####转换布尔型</p><p>“、0、undefined、null、false、NaN转换为布尔值后是false，其余为true。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>object：可以理解为一种无序数据集合。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-attr">uname</span>:<span class="hljs-string">&#x27;pink老师&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,    <span class="hljs-attr">gender</span>:<span class="hljs-string">&#x27;女&#x27;</span>&#125;<span class="hljs-comment">//查询对象属性</span>obj.<span class="hljs-property">uname</span>obj[<span class="hljs-string">&#x27;uname&#x27;</span>]（常用）<span class="hljs-comment">//添加对象属性</span>obj.<span class="hljs-property">hobby</span> = <span class="hljs-string">&#x27;足球&#x27;</span>，添加了一个新属性hobby<span class="hljs-comment">//修改对象属性</span>obj.<span class="hljs-property">gender</span> = <span class="hljs-string">&#x27;男&#x27;</span><span class="hljs-comment">//删（不推荐）</span><span class="hljs-keyword">delete</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">hobby</span><span class="hljs-comment">//对象中添加方法</span><span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-attr">uname</span>:<span class="hljs-string">&#x27;pink老师&#x27;</span>,    <span class="hljs-comment">//方法</span>    <span class="hljs-attr">sayhi</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>)    &#125;&#125;<span class="hljs-comment">//遍历对象 </span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> obj)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k)<span class="hljs-comment">//打印属性名，是字符串</span>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[k])<span class="hljs-comment">//打印属性值，不能用obj.k，因为k是字符串。</span>&#125;</code></pre><p>####js渲染原生表格</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> data = [&#123;<span class="hljs-attr">src</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-attr">num</span>:<span class="hljs-number">1225</span>&#125;,&#123;...&#125;,&#123;...&#125;];<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;data.<span class="hljs-property">length</span>; i++)&#123;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">`</span><span class="hljs-string">&lt;li&gt;</span><span class="hljs-string">&lt;a href=&quot;#&quot;&gt;</span><span class="hljs-string">&lt;img src=<span class="hljs-subst">$&#123;data[i].src&#125;</span> title=<span class="hljs-subst">$&#123;data[i].title&#125;</span></span><span class="hljs-string">&lt;/a&gt;</span><span class="hljs-string">&lt;/li&gt;`</span>)&#125;</code></pre><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p>栈：由操作系统自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p></li><li><p>堆：存放复杂类型（对象），一般由程序员分配释放，或垃圾回收机制回收。</p></li><li><p>值类型：简单数据类型/基本数据类型，存储它本身。例如：string、number、Boolean、undefined、null。</p></li><li><p>引用类型：复杂数据类型，变量中只存地址（引用）。例如：通过new关键字创建的对象，object、array、date等。</p></li></ul><h4 id="定时器函数-间歇函数"><a href="#定时器函数-间歇函数" class="headerlink" title="定时器函数-间歇函数"></a>定时器函数-间歇函数</h4><pre><code class="hljs js"><span class="hljs-built_in">setInterval</span>(函数名，间隔时间/毫秒)<span class="hljs-title function_">setInterval</span>(<span class="hljs-params"><span class="hljs-keyword">function</span>()&#123;&#125;，<span class="hljs-number">1000</span></span>)&#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;一秒执行一次&#x27;</span>)&#125;<span class="hljs-built_in">clearInterval</span>()<span class="hljs-comment">//关闭定时器</span></code></pre><p>setInterval(函数，间隔时间)</p><p>##3.3 DOM和BOM</p><p>###3.3.1 DOM:文档对象模型</p><pre><code class="hljs javascript"><span class="hljs-comment">//获取元素</span><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div ul&#x27;</span>)<span class="hljs-comment">//添加类名</span>div.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;nav box&#x27;</span>(会覆盖以前的类名)<span class="hljs-comment">//追加类</span>div.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;nav&#x27;</span>)<span class="hljs-comment">//删除类</span>div.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;nav&#x27;</span>)<span class="hljs-comment">//切换类</span>div.<span class="hljs-property">classList</span>.<span class="hljs-title function_">toggle</span>(<span class="hljs-string">&#x27;nav&#x27;</span>)<span class="hljs-comment">//表单</span>table.<span class="hljs-property">value</span><span class="hljs-comment">//表格的值</span>table.<span class="hljs-property">type</span><span class="hljs-comment">//text&amp;password</span><span class="hljs-comment">//自定义属性</span>data-自定义属性<span class="hljs-comment">//&lt;div data-id=&quot;1&quot;&gt;1&lt;/div&gt;</span></code></pre><h4 id="3-3-2-事件监听"><a href="#3-3-2-事件监听" class="headerlink" title="3.3.2 事件监听"></a>3.3.2 事件监听</h4><pre><code class="hljs javascript">元素对象.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;事件类型，要执行的函数&#x27;</span>)<span class="hljs-comment">//三要素</span><span class="hljs-comment">//事件源：被事件触发的dom元素</span><span class="hljs-comment">//事件类型：触发的方式，例如click,mouseover等</span><span class="hljs-comment">//事件调用的函数：要做什么事</span>和on的区别，可以多次绑定，不会被覆盖。常用的事件：click,mousseenter,mousseleave,foucus,blur,keydown,keyup</code></pre><h3 id="3-3-3事件对象"><a href="#3-3-3事件对象" class="headerlink" title="3.3.3事件对象"></a>3.3.3事件对象</h3><p>存储事件触发时的相关信息，在事件绑定的回调函数的第一个参数就是事件对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;input&#x27;</span>)  input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">*e*</span>) &#123;<span class="hljs-keyword">if</span> (*e*.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Enter&#x27;</span>) &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我按下了回车键&#x27;</span>)&#125;&#125;)常用属性:type、key</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#语义化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;网页后缀为html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签语义化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SEO三大标签：&lt;title&gt;，&lt;meta&gt;（description，keywords）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>事件与函数</title>
    <link href="http://example.com/2023/03/12/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2023/03/12/%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%87%BD%E6%95%B0/</id>
    <published>2023-03-12T10:40:02.387Z</published>
    <updated>2023-03-23T13:19:35.432Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事件与函数"><a href="#事件与函数" class="headerlink" title="事件与函数"></a>事件与函数</h1><blockquote><p>学会通过为DOM注册事件来实现可交互的网页特效。</p></blockquote><ul><li>能够判断函数运行的环境并确字 this 所指代的对象</li><li>理解事件的作用，知道应用事件的 3 个步骤</li></ul><blockquote><p>学习会为 DOM 注册事件，实现简单可交互的网页特交。</p></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件是编程语言中的术语，它是用来描述程序的行为或状态的，<strong>一旦行为或状态发生改变，便立即调用一个函数。</strong></p><p>例如：用户使用【鼠标点击】网页中的一个按钮、用户使用【鼠标拖拽】网页中的一张图片</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>结合 DOM 使用事件时，需要为 DOM 对象添加事件监听，等待事件发生（触发）时，便立即调用一个函数。</p><p><code>addEventListener</code> 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为【事件类型】和【事件回调】。</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>事件监听<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>事件监听<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>为 DOM 元素添加事件监听，等待事件发生，便立即执行一个函数。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>点击改变文字颜色<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 1. 获取 button 对应的 DOM 对象</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#btn&#x27;</span>)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 2. 添加事件监听</span></span><span class="language-javascript">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;等待事件被触发...&#x27;</span>)</span><span class="language-javascript">      <span class="hljs-comment">// 改变 p 标签的文字颜色</span></span><span class="language-javascript">      <span class="hljs-keyword">let</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;text&#x27;</span>)</span><span class="language-javascript">      text.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span></span><span class="language-javascript">    &#125;)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 3. 只要用户点击了按钮，事件便触发了！！！</span></span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>完成事件监听分成3个步骤：</p><ol><li>获取 DOM 元素</li><li>通过 <code>addEventListener</code> 方法为 DOM 节点添加事件监听</li><li>等待事件触发，如用户点击了某个按钮时便会触发 <code>click</code> 事件类型</li><li>事件触发后，相对应的回调函数会被执行</li></ol><p>大白话描述：所谓的事件无非就是找个机会（事件触发）调用一个函数（回调函数）。</p><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p><code>click</code> 译成中文是【点击】的意思，它的含义是监听（等着）用户鼠标的单击操作，除了【单击】还有【双击】<code>dblclick</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 双击事件类型</span></span><span class="language-javascript">  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dblclick&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;等待事件被触发...&#x27;</span>);</span><span class="language-javascript">    <span class="hljs-comment">// 改变 p 标签的文字颜色</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.text&#x27;</span>)</span><span class="language-javascript">    text.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span></span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 只要用户双击击了按钮，事件便触发了！！！</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>结论：【事件类型】决定了事件被触发的方式，如 <code>click</code> 代表鼠标单击，<code>dblclick</code> 代表鼠标双击。</p><h3 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h3><p><code>addEventListener</code> 的第2个参数是函数，这个函数会在事件被触发时立即被调用，在这个函数中可以编写任意逻辑的代码，如改变 DOM 文本颜色、文本内容等。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 双击事件类型</span></span><span class="language-javascript">  btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;dblclick&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;等待事件被触发...&#x27;</span>)</span><span class="language-javascript">    </span><span class="language-javascript">    <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.text&#x27;</span>)</span><span class="language-javascript">    <span class="hljs-comment">// 改变 p 标签的文字颜色</span></span><span class="language-javascript">    text.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span></span><span class="language-javascript">    <span class="hljs-comment">// 改变 p 标签的文本内容</span></span><span class="language-javascript">    text.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = <span class="hljs-string">&#x27;20px&#x27;</span></span><span class="language-javascript">  &#125;)</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>结论：【事件处理程序】决定了事件触发后应该执行的逻辑。</p><h2 id="事件类型-1"><a href="#事件类型-1" class="headerlink" title="事件类型"></a>事件类型</h2><p>将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等，我们逐一展开学习。</p><h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><p>鼠标事件是指跟鼠标操作相关的事件，如单击、双击、移动等。</p><ol><li>&#96;mouseenter 监听鼠标是否移入 DOM 元素</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>鼠标事件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>监听与鼠标相关的操作<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 需要事件监听的 DOM 元素</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 监听鼠标是移入当前 DOM 元素</span></span><span class="language-javascript">    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseenter&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 修改文本内容</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;鼠标移入了...&#x27;</span>;</span><span class="language-javascript">      <span class="hljs-comment">// 修改光标的风格</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">cursor</span> = <span class="hljs-string">&#x27;move&#x27;</span>;</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><ol><li>&#96;mouseleave 监听鼠标是否移出 DOM 元素</li></ol><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>鼠标事件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>监听与鼠标相关的操作<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 需要事件监听的 DOM 元素</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 监听鼠标是移出当前 DOM 元素</span></span><span class="language-javascript">    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mouseleave&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-comment">// 修改文本内容</span></span><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;鼠标移出了...&#x27;</span>;</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>keydown   键盘按下触发<br>keyup   键盘抬起触发</p><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>focus  获得焦点</p><p>blur 失去焦点</p><h3 id="文本框输入事件"><a href="#文本框输入事件" class="headerlink" title="文本框输入事件"></a>文本框输入事件</h3><p>input  </p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>事件对象<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 获取 .box 元素</span></span><span class="language-javascript">    <span class="hljs-keyword">const</span> box = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.box&#x27;</span>)</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">// 添加事件监听</span></span><span class="language-javascript">    box.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;</span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;任意事件类型被触发后，相关信息会以对象形式被记录下来...&#x27;</span>);</span><span class="language-javascript"></span><span class="language-javascript">      <span class="hljs-comment">// 事件回调函数的第1个参数即所谓的事件对象</span></span><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)</span><span class="language-javascript">    &#125;)</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre><p>事件回调函数的【第1个参数】即所谓的事件对象，通常习惯性的将这个对数命名为 <code>event</code>、<code>ev</code> 、<code>ev</code> 。</p><p>接下来简单看一下事件对象中包含了哪些有用的信息：</p><ol><li><code>ev.type</code> 当前事件的类型</li><li><code>ev.clientX/Y</code> 光标相对浏览器窗口的位置</li><li><code>ev.offsetX/Y</code> 光标相于当前 DOM 元素的位置</li></ol><p>注：在事件回调函数内部通过 window.event 同样可以获取事件对象。</p><h2 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h2><blockquote><p>能够分析判断函数运行在不同环境中 this 所指代的对象。</p></blockquote><p>环境对象指的是函数内部特殊的变量 <code>this</code> ，它代表着当前函数运行时所处的环境。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 声明函数</span></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-comment">// this 是一个变量</span></span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 声明一个对象</span></span><span class="language-javascript">  <span class="hljs-keyword">let</span> user = &#123;</span><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">sayHi</span>: sayHi <span class="hljs-comment">// 此处把 sayHi 函数，赋值给 sayHi 属性</span></span><span class="language-javascript">  &#125;</span><span class="language-javascript">  </span><span class="language-javascript">  <span class="hljs-keyword">let</span> person = &#123;</span><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;李四&#x27;</span>,</span><span class="language-javascript">    <span class="hljs-attr">sayHi</span>: sayHi</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 直接调用</span></span><span class="language-javascript">  <span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// window</span></span><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayHi</span>() <span class="hljs-comment">// window</span></span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 做为对象方法调用</span></span><span class="language-javascript">  user.<span class="hljs-title function_">sayHi</span>()<span class="hljs-comment">// user</span></span><span class="language-javascript">person.<span class="hljs-title function_">sayHi</span>()<span class="hljs-comment">// person</span></span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>结论：</p><ol><li><code>this</code> 本质上是一个变量，数据类型为对象</li><li>函数的调用方式不同 <code>this</code> 变量的值也不同</li><li>【谁调用 <code>this</code> 就是谁】是判断 <code>this</code> 值的粗略规则</li><li>函数直接调用时实际上 <code>window.sayHi()</code> 所以 <code>this</code> 的值为 <code>window</code></li></ol><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 声明 foo 函数</span></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg</span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arg);</span><span class="language-javascript">  &#125;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 普通的值做为参数</span></span><span class="language-javascript">  <span class="hljs-title function_">foo</span>(<span class="hljs-number">10</span>);</span><span class="language-javascript">  <span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;hello world!&#x27;</span>);</span><span class="language-javascript">  <span class="hljs-title function_">foo</span>([<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;css&#x27;</span>, <span class="hljs-string">&#x27;javascript&#x27;</span>]);</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;函数也能当参数...&#x27;</span>);</span><span class="language-javascript">  &#125;</span><span class="language-javascript">  <span class="hljs-comment">// 函数也可以做为参数！！！！</span></span><span class="language-javascript">  <span class="hljs-title function_">foo</span>(bar);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>函数 <code>bar</code> 做参数传给了 <code>foo</code> 函数，<code>bar</code> 就是所谓的回调函数了！！！</p><p>我们回顾一下间歇函数 <code>setInterval</code> </p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是回调函数...&#x27;</span>);</span><span class="language-javascript">  &#125;</span><span class="language-javascript">  <span class="hljs-comment">// 调用定时器</span></span><span class="language-javascript">  <span class="hljs-built_in">setInterval</span>(fn, <span class="hljs-number">1000</span>);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p><code>fn</code> 函数做为参数传给了 <code>setInterval</code> ，这便是回调函数的实际应用了，结合刚刚学习的函数表达式上述代码还有另一种更常见写法。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">  <span class="hljs-comment">// 调用定时器，匿名函数做为参数</span></span><span class="language-javascript">  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是回调函数...&#x27;</span>);</span><span class="language-javascript">  &#125;, <span class="hljs-number">1000</span>);</span><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>结论：</p><ol><li>回调函数本质还是函数，只不过把它当成参数使用</li><li>使用匿名函数做为回调函数比较常见</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;事件与函数&quot;&gt;&lt;a href=&quot;#事件与函数&quot; class=&quot;headerlink&quot; title=&quot;事件与函数&quot;&gt;&lt;/a&gt;事件与函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;学会通过为DOM注册事件来实现可交互的网页特效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://example.com/2023/03/08/markdowmGrammar/"/>
    <id>http://example.com/2023/03/08/markdowmGrammar/</id>
    <published>2023-03-08T08:50:44.887Z</published>
    <updated>2023-03-19T06:13:49.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>标题用#号来表示，#的个数增加，级数往下递增</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><p><strong>加粗</strong>  （使用**包裹）</p><p><em>斜体</em>      （ 使用*包裹）</p><p><em><strong>斜体加粗</strong></em> （使用***包裹）</p><p><del>删除线</del> （使用~~包裹）</p><p>&#x3D;&#x3D;高亮&#x3D;&#x3D;（使用&#x3D;&#x3D;包裹）</p><p>我是^上标^ （使用^包裹）</p><p>我是<del>下标</del> （使用~包裹）</p><h1 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>一二三四五</li></ul><ul><li>一二三四五 （开头携带 +或者*接空格)</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>一二三四五</li><li>上山打老虎（就是1.接空格）</li></ol><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>| Mon    | TUE    | WED    | THU    | FRI    |</p><p>| —— | —— | —— | —— | —— |</p><p>| 上山   | 上山   | 上山   | 上山   | 上山   |</p><p>| 打老虎 | 打老虎 | 打老虎 | 打老虎 | 打老虎 |</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>使用&gt;表示，个数越多，字体越大</p><blockquote><p>一二三四五</p><blockquote><p>上山打老虎</p><blockquote><p>老虎没打到</p><blockquote><p>打到小松鼠</p></blockquote></blockquote></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr><p>（就是虚线）</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><code>我是代码</code>（使用&#96;包裹）</p><pre><code class="hljs html">https://www.bilibili.com/read/cv6491991 出处：bilibili</code></pre><p>（使用 &#96;&#96;&#96;接语言类型）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、标题&quot;&gt;&lt;a href=&quot;#一、标题&quot; class=&quot;headerlink&quot; title=&quot;一、标题&quot;&gt;&lt;/a&gt;一、标题&lt;/h1&gt;&lt;p&gt;标题用#号来表示，#的个数增加，级数往下递增&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class</summary>
      
    
    
    
    
  </entry>
  
</feed>
